// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'assets_info_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

AssetsInfoModel _$AssetsInfoModelFromJson(Map<String, dynamic> json) {
  return _AssetsInfoModel.fromJson(json);
}

/// @nodoc
mixin _$AssetsInfoModel {
  String? get coinAsset => throw _privateConstructorUsedError;
  String? get optionAsset => throw _privateConstructorUsedError;
  String? get optionCoinAsset => throw _privateConstructorUsedError;
  String? get financeAsset => throw _privateConstructorUsedError;
  String? get futuresCoinAsset => throw _privateConstructorUsedError;
  String? get totalAsset => throw _privateConstructorUsedError;
  String? get unit => throw _privateConstructorUsedError;
  String? get activeCoinAsset => throw _privateConstructorUsedError;
  String? get stakingAsset => throw _privateConstructorUsedError;
  List<dynamic>? get subAccountBalances => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AssetsInfoModelCopyWith<AssetsInfoModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetsInfoModelCopyWith<$Res> {
  factory $AssetsInfoModelCopyWith(
          AssetsInfoModel value, $Res Function(AssetsInfoModel) then) =
      _$AssetsInfoModelCopyWithImpl<$Res, AssetsInfoModel>;
  @useResult
  $Res call(
      {String? coinAsset,
      String? optionAsset,
      String? optionCoinAsset,
      String? financeAsset,
      String? futuresCoinAsset,
      String? totalAsset,
      String? unit,
      String? activeCoinAsset,
      String? stakingAsset,
      List<dynamic>? subAccountBalances});
}

/// @nodoc
class _$AssetsInfoModelCopyWithImpl<$Res, $Val extends AssetsInfoModel>
    implements $AssetsInfoModelCopyWith<$Res> {
  _$AssetsInfoModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coinAsset = freezed,
    Object? optionAsset = freezed,
    Object? optionCoinAsset = freezed,
    Object? financeAsset = freezed,
    Object? futuresCoinAsset = freezed,
    Object? totalAsset = freezed,
    Object? unit = freezed,
    Object? activeCoinAsset = freezed,
    Object? stakingAsset = freezed,
    Object? subAccountBalances = freezed,
  }) {
    return _then(_value.copyWith(
      coinAsset: freezed == coinAsset
          ? _value.coinAsset
          : coinAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      optionAsset: freezed == optionAsset
          ? _value.optionAsset
          : optionAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      optionCoinAsset: freezed == optionCoinAsset
          ? _value.optionCoinAsset
          : optionCoinAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      financeAsset: freezed == financeAsset
          ? _value.financeAsset
          : financeAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      futuresCoinAsset: freezed == futuresCoinAsset
          ? _value.futuresCoinAsset
          : futuresCoinAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      totalAsset: freezed == totalAsset
          ? _value.totalAsset
          : totalAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
      activeCoinAsset: freezed == activeCoinAsset
          ? _value.activeCoinAsset
          : activeCoinAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      stakingAsset: freezed == stakingAsset
          ? _value.stakingAsset
          : stakingAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      subAccountBalances: freezed == subAccountBalances
          ? _value.subAccountBalances
          : subAccountBalances // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AssetsInfoModelImplCopyWith<$Res>
    implements $AssetsInfoModelCopyWith<$Res> {
  factory _$$AssetsInfoModelImplCopyWith(_$AssetsInfoModelImpl value,
          $Res Function(_$AssetsInfoModelImpl) then) =
      __$$AssetsInfoModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? coinAsset,
      String? optionAsset,
      String? optionCoinAsset,
      String? financeAsset,
      String? futuresCoinAsset,
      String? totalAsset,
      String? unit,
      String? activeCoinAsset,
      String? stakingAsset,
      List<dynamic>? subAccountBalances});
}

/// @nodoc
class __$$AssetsInfoModelImplCopyWithImpl<$Res>
    extends _$AssetsInfoModelCopyWithImpl<$Res, _$AssetsInfoModelImpl>
    implements _$$AssetsInfoModelImplCopyWith<$Res> {
  __$$AssetsInfoModelImplCopyWithImpl(
      _$AssetsInfoModelImpl _value, $Res Function(_$AssetsInfoModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? coinAsset = freezed,
    Object? optionAsset = freezed,
    Object? optionCoinAsset = freezed,
    Object? financeAsset = freezed,
    Object? futuresCoinAsset = freezed,
    Object? totalAsset = freezed,
    Object? unit = freezed,
    Object? activeCoinAsset = freezed,
    Object? stakingAsset = freezed,
    Object? subAccountBalances = freezed,
  }) {
    return _then(_$AssetsInfoModelImpl(
      coinAsset: freezed == coinAsset
          ? _value.coinAsset
          : coinAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      optionAsset: freezed == optionAsset
          ? _value.optionAsset
          : optionAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      optionCoinAsset: freezed == optionCoinAsset
          ? _value.optionCoinAsset
          : optionCoinAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      financeAsset: freezed == financeAsset
          ? _value.financeAsset
          : financeAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      futuresCoinAsset: freezed == futuresCoinAsset
          ? _value.futuresCoinAsset
          : futuresCoinAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      totalAsset: freezed == totalAsset
          ? _value.totalAsset
          : totalAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
      activeCoinAsset: freezed == activeCoinAsset
          ? _value.activeCoinAsset
          : activeCoinAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      stakingAsset: freezed == stakingAsset
          ? _value.stakingAsset
          : stakingAsset // ignore: cast_nullable_to_non_nullable
              as String?,
      subAccountBalances: freezed == subAccountBalances
          ? _value._subAccountBalances
          : subAccountBalances // ignore: cast_nullable_to_non_nullable
              as List<dynamic>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AssetsInfoModelImpl
    with DiagnosticableTreeMixin
    implements _AssetsInfoModel {
  const _$AssetsInfoModelImpl(
      {this.coinAsset,
      this.optionAsset,
      this.optionCoinAsset,
      this.financeAsset,
      this.futuresCoinAsset,
      this.totalAsset,
      this.unit,
      this.activeCoinAsset,
      this.stakingAsset,
      final List<dynamic>? subAccountBalances})
      : _subAccountBalances = subAccountBalances;

  factory _$AssetsInfoModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AssetsInfoModelImplFromJson(json);

  @override
  final String? coinAsset;
  @override
  final String? optionAsset;
  @override
  final String? optionCoinAsset;
  @override
  final String? financeAsset;
  @override
  final String? futuresCoinAsset;
  @override
  final String? totalAsset;
  @override
  final String? unit;
  @override
  final String? activeCoinAsset;
  @override
  final String? stakingAsset;
  final List<dynamic>? _subAccountBalances;
  @override
  List<dynamic>? get subAccountBalances {
    final value = _subAccountBalances;
    if (value == null) return null;
    if (_subAccountBalances is EqualUnmodifiableListView)
      return _subAccountBalances;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AssetsInfoModel(coinAsset: $coinAsset, optionAsset: $optionAsset, optionCoinAsset: $optionCoinAsset, financeAsset: $financeAsset, futuresCoinAsset: $futuresCoinAsset, totalAsset: $totalAsset, unit: $unit, activeCoinAsset: $activeCoinAsset, stakingAsset: $stakingAsset, subAccountBalances: $subAccountBalances)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AssetsInfoModel'))
      ..add(DiagnosticsProperty('coinAsset', coinAsset))
      ..add(DiagnosticsProperty('optionAsset', optionAsset))
      ..add(DiagnosticsProperty('optionCoinAsset', optionCoinAsset))
      ..add(DiagnosticsProperty('financeAsset', financeAsset))
      ..add(DiagnosticsProperty('futuresCoinAsset', futuresCoinAsset))
      ..add(DiagnosticsProperty('totalAsset', totalAsset))
      ..add(DiagnosticsProperty('unit', unit))
      ..add(DiagnosticsProperty('activeCoinAsset', activeCoinAsset))
      ..add(DiagnosticsProperty('stakingAsset', stakingAsset))
      ..add(DiagnosticsProperty('subAccountBalances', subAccountBalances));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AssetsInfoModelImpl &&
            (identical(other.coinAsset, coinAsset) ||
                other.coinAsset == coinAsset) &&
            (identical(other.optionAsset, optionAsset) ||
                other.optionAsset == optionAsset) &&
            (identical(other.optionCoinAsset, optionCoinAsset) ||
                other.optionCoinAsset == optionCoinAsset) &&
            (identical(other.financeAsset, financeAsset) ||
                other.financeAsset == financeAsset) &&
            (identical(other.futuresCoinAsset, futuresCoinAsset) ||
                other.futuresCoinAsset == futuresCoinAsset) &&
            (identical(other.totalAsset, totalAsset) ||
                other.totalAsset == totalAsset) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.activeCoinAsset, activeCoinAsset) ||
                other.activeCoinAsset == activeCoinAsset) &&
            (identical(other.stakingAsset, stakingAsset) ||
                other.stakingAsset == stakingAsset) &&
            const DeepCollectionEquality()
                .equals(other._subAccountBalances, _subAccountBalances));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      coinAsset,
      optionAsset,
      optionCoinAsset,
      financeAsset,
      futuresCoinAsset,
      totalAsset,
      unit,
      activeCoinAsset,
      stakingAsset,
      const DeepCollectionEquality().hash(_subAccountBalances));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AssetsInfoModelImplCopyWith<_$AssetsInfoModelImpl> get copyWith =>
      __$$AssetsInfoModelImplCopyWithImpl<_$AssetsInfoModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AssetsInfoModelImplToJson(
      this,
    );
  }
}

abstract class _AssetsInfoModel implements AssetsInfoModel {
  const factory _AssetsInfoModel(
      {final String? coinAsset,
      final String? optionAsset,
      final String? optionCoinAsset,
      final String? financeAsset,
      final String? futuresCoinAsset,
      final String? totalAsset,
      final String? unit,
      final String? activeCoinAsset,
      final String? stakingAsset,
      final List<dynamic>? subAccountBalances}) = _$AssetsInfoModelImpl;

  factory _AssetsInfoModel.fromJson(Map<String, dynamic> json) =
      _$AssetsInfoModelImpl.fromJson;

  @override
  String? get coinAsset;
  @override
  String? get optionAsset;
  @override
  String? get optionCoinAsset;
  @override
  String? get financeAsset;
  @override
  String? get futuresCoinAsset;
  @override
  String? get totalAsset;
  @override
  String? get unit;
  @override
  String? get activeCoinAsset;
  @override
  String? get stakingAsset;
  @override
  List<dynamic>? get subAccountBalances;
  @override
  @JsonKey(ignore: true)
  _$$AssetsInfoModelImplCopyWith<_$AssetsInfoModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
