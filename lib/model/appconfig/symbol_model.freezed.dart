// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'symbol_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SymbolModel _$SymbolModelFromJson(Map<String, dynamic> json) {
  return _SymbolModel.fromJson(json);
}

/// @nodoc
mixin _$SymbolModel {
  String? get orgId => throw _privateConstructorUsedError;
  String? get exchangeId => throw _privateConstructorUsedError;
  String? get symbolId => throw _privateConstructorUsedError;
  String? get symbolName => throw _privateConstructorUsedError;
  String? get baseTokenId => throw _privateConstructorUsedError;
  String? get baseTokenName => throw _privateConstructorUsedError;
  String? get quoteTokenId => throw _privateConstructorUsedError;
  String? get quoteTokenName => throw _privateConstructorUsedError;
  String? get basePrecision => throw _privateConstructorUsedError;
  String? get quotePrecision => throw _privateConstructorUsedError;
  String? get minTradeQuantity => throw _privateConstructorUsedError;
  String? get minTradeAmount => throw _privateConstructorUsedError;
  String? get minPricePrecision => throw _privateConstructorUsedError;
  String? get digitMerge => throw _privateConstructorUsedError;
  bool? get canTrade => throw _privateConstructorUsedError;
  int? get customOrder => throw _privateConstructorUsedError;
  bool? get isAggregate => throw _privateConstructorUsedError;
  int? get indexRecommendOrder => throw _privateConstructorUsedError;
  bool? get showStatus => throw _privateConstructorUsedError;
  int? get category => throw _privateConstructorUsedError;
  bool? get allowMargin => throw _privateConstructorUsedError;
  String? get labelId => throw _privateConstructorUsedError;
  String? get iconUrl => throw _privateConstructorUsedError;
  bool? get allowPlan => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $SymbolModelCopyWith<SymbolModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SymbolModelCopyWith<$Res> {
  factory $SymbolModelCopyWith(
          SymbolModel value, $Res Function(SymbolModel) then) =
      _$SymbolModelCopyWithImpl<$Res, SymbolModel>;
  @useResult
  $Res call(
      {String? orgId,
      String? exchangeId,
      String? symbolId,
      String? symbolName,
      String? baseTokenId,
      String? baseTokenName,
      String? quoteTokenId,
      String? quoteTokenName,
      String? basePrecision,
      String? quotePrecision,
      String? minTradeQuantity,
      String? minTradeAmount,
      String? minPricePrecision,
      String? digitMerge,
      bool? canTrade,
      int? customOrder,
      bool? isAggregate,
      int? indexRecommendOrder,
      bool? showStatus,
      int? category,
      bool? allowMargin,
      String? labelId,
      String? iconUrl,
      bool? allowPlan});
}

/// @nodoc
class _$SymbolModelCopyWithImpl<$Res, $Val extends SymbolModel>
    implements $SymbolModelCopyWith<$Res> {
  _$SymbolModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? orgId = freezed,
    Object? exchangeId = freezed,
    Object? symbolId = freezed,
    Object? symbolName = freezed,
    Object? baseTokenId = freezed,
    Object? baseTokenName = freezed,
    Object? quoteTokenId = freezed,
    Object? quoteTokenName = freezed,
    Object? basePrecision = freezed,
    Object? quotePrecision = freezed,
    Object? minTradeQuantity = freezed,
    Object? minTradeAmount = freezed,
    Object? minPricePrecision = freezed,
    Object? digitMerge = freezed,
    Object? canTrade = freezed,
    Object? customOrder = freezed,
    Object? isAggregate = freezed,
    Object? indexRecommendOrder = freezed,
    Object? showStatus = freezed,
    Object? category = freezed,
    Object? allowMargin = freezed,
    Object? labelId = freezed,
    Object? iconUrl = freezed,
    Object? allowPlan = freezed,
  }) {
    return _then(_value.copyWith(
      orgId: freezed == orgId
          ? _value.orgId
          : orgId // ignore: cast_nullable_to_non_nullable
              as String?,
      exchangeId: freezed == exchangeId
          ? _value.exchangeId
          : exchangeId // ignore: cast_nullable_to_non_nullable
              as String?,
      symbolId: freezed == symbolId
          ? _value.symbolId
          : symbolId // ignore: cast_nullable_to_non_nullable
              as String?,
      symbolName: freezed == symbolName
          ? _value.symbolName
          : symbolName // ignore: cast_nullable_to_non_nullable
              as String?,
      baseTokenId: freezed == baseTokenId
          ? _value.baseTokenId
          : baseTokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      baseTokenName: freezed == baseTokenName
          ? _value.baseTokenName
          : baseTokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      quoteTokenId: freezed == quoteTokenId
          ? _value.quoteTokenId
          : quoteTokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      quoteTokenName: freezed == quoteTokenName
          ? _value.quoteTokenName
          : quoteTokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      basePrecision: freezed == basePrecision
          ? _value.basePrecision
          : basePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      quotePrecision: freezed == quotePrecision
          ? _value.quotePrecision
          : quotePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      minTradeQuantity: freezed == minTradeQuantity
          ? _value.minTradeQuantity
          : minTradeQuantity // ignore: cast_nullable_to_non_nullable
              as String?,
      minTradeAmount: freezed == minTradeAmount
          ? _value.minTradeAmount
          : minTradeAmount // ignore: cast_nullable_to_non_nullable
              as String?,
      minPricePrecision: freezed == minPricePrecision
          ? _value.minPricePrecision
          : minPricePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      digitMerge: freezed == digitMerge
          ? _value.digitMerge
          : digitMerge // ignore: cast_nullable_to_non_nullable
              as String?,
      canTrade: freezed == canTrade
          ? _value.canTrade
          : canTrade // ignore: cast_nullable_to_non_nullable
              as bool?,
      customOrder: freezed == customOrder
          ? _value.customOrder
          : customOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      isAggregate: freezed == isAggregate
          ? _value.isAggregate
          : isAggregate // ignore: cast_nullable_to_non_nullable
              as bool?,
      indexRecommendOrder: freezed == indexRecommendOrder
          ? _value.indexRecommendOrder
          : indexRecommendOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      showStatus: freezed == showStatus
          ? _value.showStatus
          : showStatus // ignore: cast_nullable_to_non_nullable
              as bool?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as int?,
      allowMargin: freezed == allowMargin
          ? _value.allowMargin
          : allowMargin // ignore: cast_nullable_to_non_nullable
              as bool?,
      labelId: freezed == labelId
          ? _value.labelId
          : labelId // ignore: cast_nullable_to_non_nullable
              as String?,
      iconUrl: freezed == iconUrl
          ? _value.iconUrl
          : iconUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      allowPlan: freezed == allowPlan
          ? _value.allowPlan
          : allowPlan // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SymbolModelImplCopyWith<$Res>
    implements $SymbolModelCopyWith<$Res> {
  factory _$$SymbolModelImplCopyWith(
          _$SymbolModelImpl value, $Res Function(_$SymbolModelImpl) then) =
      __$$SymbolModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? orgId,
      String? exchangeId,
      String? symbolId,
      String? symbolName,
      String? baseTokenId,
      String? baseTokenName,
      String? quoteTokenId,
      String? quoteTokenName,
      String? basePrecision,
      String? quotePrecision,
      String? minTradeQuantity,
      String? minTradeAmount,
      String? minPricePrecision,
      String? digitMerge,
      bool? canTrade,
      int? customOrder,
      bool? isAggregate,
      int? indexRecommendOrder,
      bool? showStatus,
      int? category,
      bool? allowMargin,
      String? labelId,
      String? iconUrl,
      bool? allowPlan});
}

/// @nodoc
class __$$SymbolModelImplCopyWithImpl<$Res>
    extends _$SymbolModelCopyWithImpl<$Res, _$SymbolModelImpl>
    implements _$$SymbolModelImplCopyWith<$Res> {
  __$$SymbolModelImplCopyWithImpl(
      _$SymbolModelImpl _value, $Res Function(_$SymbolModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? orgId = freezed,
    Object? exchangeId = freezed,
    Object? symbolId = freezed,
    Object? symbolName = freezed,
    Object? baseTokenId = freezed,
    Object? baseTokenName = freezed,
    Object? quoteTokenId = freezed,
    Object? quoteTokenName = freezed,
    Object? basePrecision = freezed,
    Object? quotePrecision = freezed,
    Object? minTradeQuantity = freezed,
    Object? minTradeAmount = freezed,
    Object? minPricePrecision = freezed,
    Object? digitMerge = freezed,
    Object? canTrade = freezed,
    Object? customOrder = freezed,
    Object? isAggregate = freezed,
    Object? indexRecommendOrder = freezed,
    Object? showStatus = freezed,
    Object? category = freezed,
    Object? allowMargin = freezed,
    Object? labelId = freezed,
    Object? iconUrl = freezed,
    Object? allowPlan = freezed,
  }) {
    return _then(_$SymbolModelImpl(
      orgId: freezed == orgId
          ? _value.orgId
          : orgId // ignore: cast_nullable_to_non_nullable
              as String?,
      exchangeId: freezed == exchangeId
          ? _value.exchangeId
          : exchangeId // ignore: cast_nullable_to_non_nullable
              as String?,
      symbolId: freezed == symbolId
          ? _value.symbolId
          : symbolId // ignore: cast_nullable_to_non_nullable
              as String?,
      symbolName: freezed == symbolName
          ? _value.symbolName
          : symbolName // ignore: cast_nullable_to_non_nullable
              as String?,
      baseTokenId: freezed == baseTokenId
          ? _value.baseTokenId
          : baseTokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      baseTokenName: freezed == baseTokenName
          ? _value.baseTokenName
          : baseTokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      quoteTokenId: freezed == quoteTokenId
          ? _value.quoteTokenId
          : quoteTokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      quoteTokenName: freezed == quoteTokenName
          ? _value.quoteTokenName
          : quoteTokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      basePrecision: freezed == basePrecision
          ? _value.basePrecision
          : basePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      quotePrecision: freezed == quotePrecision
          ? _value.quotePrecision
          : quotePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      minTradeQuantity: freezed == minTradeQuantity
          ? _value.minTradeQuantity
          : minTradeQuantity // ignore: cast_nullable_to_non_nullable
              as String?,
      minTradeAmount: freezed == minTradeAmount
          ? _value.minTradeAmount
          : minTradeAmount // ignore: cast_nullable_to_non_nullable
              as String?,
      minPricePrecision: freezed == minPricePrecision
          ? _value.minPricePrecision
          : minPricePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      digitMerge: freezed == digitMerge
          ? _value.digitMerge
          : digitMerge // ignore: cast_nullable_to_non_nullable
              as String?,
      canTrade: freezed == canTrade
          ? _value.canTrade
          : canTrade // ignore: cast_nullable_to_non_nullable
              as bool?,
      customOrder: freezed == customOrder
          ? _value.customOrder
          : customOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      isAggregate: freezed == isAggregate
          ? _value.isAggregate
          : isAggregate // ignore: cast_nullable_to_non_nullable
              as bool?,
      indexRecommendOrder: freezed == indexRecommendOrder
          ? _value.indexRecommendOrder
          : indexRecommendOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      showStatus: freezed == showStatus
          ? _value.showStatus
          : showStatus // ignore: cast_nullable_to_non_nullable
              as bool?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as int?,
      allowMargin: freezed == allowMargin
          ? _value.allowMargin
          : allowMargin // ignore: cast_nullable_to_non_nullable
              as bool?,
      labelId: freezed == labelId
          ? _value.labelId
          : labelId // ignore: cast_nullable_to_non_nullable
              as String?,
      iconUrl: freezed == iconUrl
          ? _value.iconUrl
          : iconUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      allowPlan: freezed == allowPlan
          ? _value.allowPlan
          : allowPlan // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SymbolModelImpl with DiagnosticableTreeMixin implements _SymbolModel {
  const _$SymbolModelImpl(
      {this.orgId,
      this.exchangeId,
      this.symbolId,
      this.symbolName,
      this.baseTokenId,
      this.baseTokenName,
      this.quoteTokenId,
      this.quoteTokenName,
      this.basePrecision,
      this.quotePrecision,
      this.minTradeQuantity,
      this.minTradeAmount,
      this.minPricePrecision,
      this.digitMerge,
      this.canTrade,
      this.customOrder,
      this.isAggregate,
      this.indexRecommendOrder,
      this.showStatus,
      this.category,
      this.allowMargin,
      this.labelId,
      this.iconUrl,
      this.allowPlan});

  factory _$SymbolModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$SymbolModelImplFromJson(json);

  @override
  final String? orgId;
  @override
  final String? exchangeId;
  @override
  final String? symbolId;
  @override
  final String? symbolName;
  @override
  final String? baseTokenId;
  @override
  final String? baseTokenName;
  @override
  final String? quoteTokenId;
  @override
  final String? quoteTokenName;
  @override
  final String? basePrecision;
  @override
  final String? quotePrecision;
  @override
  final String? minTradeQuantity;
  @override
  final String? minTradeAmount;
  @override
  final String? minPricePrecision;
  @override
  final String? digitMerge;
  @override
  final bool? canTrade;
  @override
  final int? customOrder;
  @override
  final bool? isAggregate;
  @override
  final int? indexRecommendOrder;
  @override
  final bool? showStatus;
  @override
  final int? category;
  @override
  final bool? allowMargin;
  @override
  final String? labelId;
  @override
  final String? iconUrl;
  @override
  final bool? allowPlan;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SymbolModel(orgId: $orgId, exchangeId: $exchangeId, symbolId: $symbolId, symbolName: $symbolName, baseTokenId: $baseTokenId, baseTokenName: $baseTokenName, quoteTokenId: $quoteTokenId, quoteTokenName: $quoteTokenName, basePrecision: $basePrecision, quotePrecision: $quotePrecision, minTradeQuantity: $minTradeQuantity, minTradeAmount: $minTradeAmount, minPricePrecision: $minPricePrecision, digitMerge: $digitMerge, canTrade: $canTrade, customOrder: $customOrder, isAggregate: $isAggregate, indexRecommendOrder: $indexRecommendOrder, showStatus: $showStatus, category: $category, allowMargin: $allowMargin, labelId: $labelId, iconUrl: $iconUrl, allowPlan: $allowPlan)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SymbolModel'))
      ..add(DiagnosticsProperty('orgId', orgId))
      ..add(DiagnosticsProperty('exchangeId', exchangeId))
      ..add(DiagnosticsProperty('symbolId', symbolId))
      ..add(DiagnosticsProperty('symbolName', symbolName))
      ..add(DiagnosticsProperty('baseTokenId', baseTokenId))
      ..add(DiagnosticsProperty('baseTokenName', baseTokenName))
      ..add(DiagnosticsProperty('quoteTokenId', quoteTokenId))
      ..add(DiagnosticsProperty('quoteTokenName', quoteTokenName))
      ..add(DiagnosticsProperty('basePrecision', basePrecision))
      ..add(DiagnosticsProperty('quotePrecision', quotePrecision))
      ..add(DiagnosticsProperty('minTradeQuantity', minTradeQuantity))
      ..add(DiagnosticsProperty('minTradeAmount', minTradeAmount))
      ..add(DiagnosticsProperty('minPricePrecision', minPricePrecision))
      ..add(DiagnosticsProperty('digitMerge', digitMerge))
      ..add(DiagnosticsProperty('canTrade', canTrade))
      ..add(DiagnosticsProperty('customOrder', customOrder))
      ..add(DiagnosticsProperty('isAggregate', isAggregate))
      ..add(DiagnosticsProperty('indexRecommendOrder', indexRecommendOrder))
      ..add(DiagnosticsProperty('showStatus', showStatus))
      ..add(DiagnosticsProperty('category', category))
      ..add(DiagnosticsProperty('allowMargin', allowMargin))
      ..add(DiagnosticsProperty('labelId', labelId))
      ..add(DiagnosticsProperty('iconUrl', iconUrl))
      ..add(DiagnosticsProperty('allowPlan', allowPlan));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SymbolModelImpl &&
            (identical(other.orgId, orgId) || other.orgId == orgId) &&
            (identical(other.exchangeId, exchangeId) ||
                other.exchangeId == exchangeId) &&
            (identical(other.symbolId, symbolId) ||
                other.symbolId == symbolId) &&
            (identical(other.symbolName, symbolName) ||
                other.symbolName == symbolName) &&
            (identical(other.baseTokenId, baseTokenId) ||
                other.baseTokenId == baseTokenId) &&
            (identical(other.baseTokenName, baseTokenName) ||
                other.baseTokenName == baseTokenName) &&
            (identical(other.quoteTokenId, quoteTokenId) ||
                other.quoteTokenId == quoteTokenId) &&
            (identical(other.quoteTokenName, quoteTokenName) ||
                other.quoteTokenName == quoteTokenName) &&
            (identical(other.basePrecision, basePrecision) ||
                other.basePrecision == basePrecision) &&
            (identical(other.quotePrecision, quotePrecision) ||
                other.quotePrecision == quotePrecision) &&
            (identical(other.minTradeQuantity, minTradeQuantity) ||
                other.minTradeQuantity == minTradeQuantity) &&
            (identical(other.minTradeAmount, minTradeAmount) ||
                other.minTradeAmount == minTradeAmount) &&
            (identical(other.minPricePrecision, minPricePrecision) ||
                other.minPricePrecision == minPricePrecision) &&
            (identical(other.digitMerge, digitMerge) ||
                other.digitMerge == digitMerge) &&
            (identical(other.canTrade, canTrade) ||
                other.canTrade == canTrade) &&
            (identical(other.customOrder, customOrder) ||
                other.customOrder == customOrder) &&
            (identical(other.isAggregate, isAggregate) ||
                other.isAggregate == isAggregate) &&
            (identical(other.indexRecommendOrder, indexRecommendOrder) ||
                other.indexRecommendOrder == indexRecommendOrder) &&
            (identical(other.showStatus, showStatus) ||
                other.showStatus == showStatus) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.allowMargin, allowMargin) ||
                other.allowMargin == allowMargin) &&
            (identical(other.labelId, labelId) || other.labelId == labelId) &&
            (identical(other.iconUrl, iconUrl) || other.iconUrl == iconUrl) &&
            (identical(other.allowPlan, allowPlan) ||
                other.allowPlan == allowPlan));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        orgId,
        exchangeId,
        symbolId,
        symbolName,
        baseTokenId,
        baseTokenName,
        quoteTokenId,
        quoteTokenName,
        basePrecision,
        quotePrecision,
        minTradeQuantity,
        minTradeAmount,
        minPricePrecision,
        digitMerge,
        canTrade,
        customOrder,
        isAggregate,
        indexRecommendOrder,
        showStatus,
        category,
        allowMargin,
        labelId,
        iconUrl,
        allowPlan
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SymbolModelImplCopyWith<_$SymbolModelImpl> get copyWith =>
      __$$SymbolModelImplCopyWithImpl<_$SymbolModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SymbolModelImplToJson(
      this,
    );
  }
}

abstract class _SymbolModel implements SymbolModel {
  const factory _SymbolModel(
      {final String? orgId,
      final String? exchangeId,
      final String? symbolId,
      final String? symbolName,
      final String? baseTokenId,
      final String? baseTokenName,
      final String? quoteTokenId,
      final String? quoteTokenName,
      final String? basePrecision,
      final String? quotePrecision,
      final String? minTradeQuantity,
      final String? minTradeAmount,
      final String? minPricePrecision,
      final String? digitMerge,
      final bool? canTrade,
      final int? customOrder,
      final bool? isAggregate,
      final int? indexRecommendOrder,
      final bool? showStatus,
      final int? category,
      final bool? allowMargin,
      final String? labelId,
      final String? iconUrl,
      final bool? allowPlan}) = _$SymbolModelImpl;

  factory _SymbolModel.fromJson(Map<String, dynamic> json) =
      _$SymbolModelImpl.fromJson;

  @override
  String? get orgId;
  @override
  String? get exchangeId;
  @override
  String? get symbolId;
  @override
  String? get symbolName;
  @override
  String? get baseTokenId;
  @override
  String? get baseTokenName;
  @override
  String? get quoteTokenId;
  @override
  String? get quoteTokenName;
  @override
  String? get basePrecision;
  @override
  String? get quotePrecision;
  @override
  String? get minTradeQuantity;
  @override
  String? get minTradeAmount;
  @override
  String? get minPricePrecision;
  @override
  String? get digitMerge;
  @override
  bool? get canTrade;
  @override
  int? get customOrder;
  @override
  bool? get isAggregate;
  @override
  int? get indexRecommendOrder;
  @override
  bool? get showStatus;
  @override
  int? get category;
  @override
  bool? get allowMargin;
  @override
  String? get labelId;
  @override
  String? get iconUrl;
  @override
  bool? get allowPlan;
  @override
  @JsonKey(ignore: true)
  _$$SymbolModelImplCopyWith<_$SymbolModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TokenModel _$TokenModelFromJson(Map<String, dynamic> json) {
  return _TokenModel.fromJson(json);
}

/// @nodoc
mixin _$TokenModel {
  String? get orgId => throw _privateConstructorUsedError;
  String? get tokenId => throw _privateConstructorUsedError;
  String? get tokenName => throw _privateConstructorUsedError;
  String? get tokenFullName => throw _privateConstructorUsedError;
  String? get iconUrl => throw _privateConstructorUsedError;
  bool? get allowWithdraw => throw _privateConstructorUsedError;
  bool? get allowDeposit => throw _privateConstructorUsedError;
  bool? get isHighRiskToken => throw _privateConstructorUsedError;
  bool? get isEOS => throw _privateConstructorUsedError;
  String? get tokenType => throw _privateConstructorUsedError;
  bool? get needAddressTag => throw _privateConstructorUsedError;
  String? get needKycQuantity => throw _privateConstructorUsedError;
  int? get customOrder => throw _privateConstructorUsedError;
  List<SymbolModel>? get baseTokenSymbols => throw _privateConstructorUsedError;
  List<ChainTypesModel>? get chainTypes => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TokenModelCopyWith<TokenModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TokenModelCopyWith<$Res> {
  factory $TokenModelCopyWith(
          TokenModel value, $Res Function(TokenModel) then) =
      _$TokenModelCopyWithImpl<$Res, TokenModel>;
  @useResult
  $Res call(
      {String? orgId,
      String? tokenId,
      String? tokenName,
      String? tokenFullName,
      String? iconUrl,
      bool? allowWithdraw,
      bool? allowDeposit,
      bool? isHighRiskToken,
      bool? isEOS,
      String? tokenType,
      bool? needAddressTag,
      String? needKycQuantity,
      int? customOrder,
      List<SymbolModel>? baseTokenSymbols,
      List<ChainTypesModel>? chainTypes});
}

/// @nodoc
class _$TokenModelCopyWithImpl<$Res, $Val extends TokenModel>
    implements $TokenModelCopyWith<$Res> {
  _$TokenModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? orgId = freezed,
    Object? tokenId = freezed,
    Object? tokenName = freezed,
    Object? tokenFullName = freezed,
    Object? iconUrl = freezed,
    Object? allowWithdraw = freezed,
    Object? allowDeposit = freezed,
    Object? isHighRiskToken = freezed,
    Object? isEOS = freezed,
    Object? tokenType = freezed,
    Object? needAddressTag = freezed,
    Object? needKycQuantity = freezed,
    Object? customOrder = freezed,
    Object? baseTokenSymbols = freezed,
    Object? chainTypes = freezed,
  }) {
    return _then(_value.copyWith(
      orgId: freezed == orgId
          ? _value.orgId
          : orgId // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenId: freezed == tokenId
          ? _value.tokenId
          : tokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenName: freezed == tokenName
          ? _value.tokenName
          : tokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenFullName: freezed == tokenFullName
          ? _value.tokenFullName
          : tokenFullName // ignore: cast_nullable_to_non_nullable
              as String?,
      iconUrl: freezed == iconUrl
          ? _value.iconUrl
          : iconUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      allowWithdraw: freezed == allowWithdraw
          ? _value.allowWithdraw
          : allowWithdraw // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowDeposit: freezed == allowDeposit
          ? _value.allowDeposit
          : allowDeposit // ignore: cast_nullable_to_non_nullable
              as bool?,
      isHighRiskToken: freezed == isHighRiskToken
          ? _value.isHighRiskToken
          : isHighRiskToken // ignore: cast_nullable_to_non_nullable
              as bool?,
      isEOS: freezed == isEOS
          ? _value.isEOS
          : isEOS // ignore: cast_nullable_to_non_nullable
              as bool?,
      tokenType: freezed == tokenType
          ? _value.tokenType
          : tokenType // ignore: cast_nullable_to_non_nullable
              as String?,
      needAddressTag: freezed == needAddressTag
          ? _value.needAddressTag
          : needAddressTag // ignore: cast_nullable_to_non_nullable
              as bool?,
      needKycQuantity: freezed == needKycQuantity
          ? _value.needKycQuantity
          : needKycQuantity // ignore: cast_nullable_to_non_nullable
              as String?,
      customOrder: freezed == customOrder
          ? _value.customOrder
          : customOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      baseTokenSymbols: freezed == baseTokenSymbols
          ? _value.baseTokenSymbols
          : baseTokenSymbols // ignore: cast_nullable_to_non_nullable
              as List<SymbolModel>?,
      chainTypes: freezed == chainTypes
          ? _value.chainTypes
          : chainTypes // ignore: cast_nullable_to_non_nullable
              as List<ChainTypesModel>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TokenModelImplCopyWith<$Res>
    implements $TokenModelCopyWith<$Res> {
  factory _$$TokenModelImplCopyWith(
          _$TokenModelImpl value, $Res Function(_$TokenModelImpl) then) =
      __$$TokenModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? orgId,
      String? tokenId,
      String? tokenName,
      String? tokenFullName,
      String? iconUrl,
      bool? allowWithdraw,
      bool? allowDeposit,
      bool? isHighRiskToken,
      bool? isEOS,
      String? tokenType,
      bool? needAddressTag,
      String? needKycQuantity,
      int? customOrder,
      List<SymbolModel>? baseTokenSymbols,
      List<ChainTypesModel>? chainTypes});
}

/// @nodoc
class __$$TokenModelImplCopyWithImpl<$Res>
    extends _$TokenModelCopyWithImpl<$Res, _$TokenModelImpl>
    implements _$$TokenModelImplCopyWith<$Res> {
  __$$TokenModelImplCopyWithImpl(
      _$TokenModelImpl _value, $Res Function(_$TokenModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? orgId = freezed,
    Object? tokenId = freezed,
    Object? tokenName = freezed,
    Object? tokenFullName = freezed,
    Object? iconUrl = freezed,
    Object? allowWithdraw = freezed,
    Object? allowDeposit = freezed,
    Object? isHighRiskToken = freezed,
    Object? isEOS = freezed,
    Object? tokenType = freezed,
    Object? needAddressTag = freezed,
    Object? needKycQuantity = freezed,
    Object? customOrder = freezed,
    Object? baseTokenSymbols = freezed,
    Object? chainTypes = freezed,
  }) {
    return _then(_$TokenModelImpl(
      orgId: freezed == orgId
          ? _value.orgId
          : orgId // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenId: freezed == tokenId
          ? _value.tokenId
          : tokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenName: freezed == tokenName
          ? _value.tokenName
          : tokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenFullName: freezed == tokenFullName
          ? _value.tokenFullName
          : tokenFullName // ignore: cast_nullable_to_non_nullable
              as String?,
      iconUrl: freezed == iconUrl
          ? _value.iconUrl
          : iconUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      allowWithdraw: freezed == allowWithdraw
          ? _value.allowWithdraw
          : allowWithdraw // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowDeposit: freezed == allowDeposit
          ? _value.allowDeposit
          : allowDeposit // ignore: cast_nullable_to_non_nullable
              as bool?,
      isHighRiskToken: freezed == isHighRiskToken
          ? _value.isHighRiskToken
          : isHighRiskToken // ignore: cast_nullable_to_non_nullable
              as bool?,
      isEOS: freezed == isEOS
          ? _value.isEOS
          : isEOS // ignore: cast_nullable_to_non_nullable
              as bool?,
      tokenType: freezed == tokenType
          ? _value.tokenType
          : tokenType // ignore: cast_nullable_to_non_nullable
              as String?,
      needAddressTag: freezed == needAddressTag
          ? _value.needAddressTag
          : needAddressTag // ignore: cast_nullable_to_non_nullable
              as bool?,
      needKycQuantity: freezed == needKycQuantity
          ? _value.needKycQuantity
          : needKycQuantity // ignore: cast_nullable_to_non_nullable
              as String?,
      customOrder: freezed == customOrder
          ? _value.customOrder
          : customOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      baseTokenSymbols: freezed == baseTokenSymbols
          ? _value._baseTokenSymbols
          : baseTokenSymbols // ignore: cast_nullable_to_non_nullable
              as List<SymbolModel>?,
      chainTypes: freezed == chainTypes
          ? _value._chainTypes
          : chainTypes // ignore: cast_nullable_to_non_nullable
              as List<ChainTypesModel>?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TokenModelImpl with DiagnosticableTreeMixin implements _TokenModel {
  const _$TokenModelImpl(
      {this.orgId,
      this.tokenId,
      this.tokenName,
      this.tokenFullName,
      this.iconUrl,
      this.allowWithdraw,
      this.allowDeposit,
      this.isHighRiskToken,
      this.isEOS,
      this.tokenType,
      this.needAddressTag,
      this.needKycQuantity,
      this.customOrder,
      final List<SymbolModel>? baseTokenSymbols,
      final List<ChainTypesModel>? chainTypes})
      : _baseTokenSymbols = baseTokenSymbols,
        _chainTypes = chainTypes;

  factory _$TokenModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$TokenModelImplFromJson(json);

  @override
  final String? orgId;
  @override
  final String? tokenId;
  @override
  final String? tokenName;
  @override
  final String? tokenFullName;
  @override
  final String? iconUrl;
  @override
  final bool? allowWithdraw;
  @override
  final bool? allowDeposit;
  @override
  final bool? isHighRiskToken;
  @override
  final bool? isEOS;
  @override
  final String? tokenType;
  @override
  final bool? needAddressTag;
  @override
  final String? needKycQuantity;
  @override
  final int? customOrder;
  final List<SymbolModel>? _baseTokenSymbols;
  @override
  List<SymbolModel>? get baseTokenSymbols {
    final value = _baseTokenSymbols;
    if (value == null) return null;
    if (_baseTokenSymbols is EqualUnmodifiableListView)
      return _baseTokenSymbols;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<ChainTypesModel>? _chainTypes;
  @override
  List<ChainTypesModel>? get chainTypes {
    final value = _chainTypes;
    if (value == null) return null;
    if (_chainTypes is EqualUnmodifiableListView) return _chainTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TokenModel(orgId: $orgId, tokenId: $tokenId, tokenName: $tokenName, tokenFullName: $tokenFullName, iconUrl: $iconUrl, allowWithdraw: $allowWithdraw, allowDeposit: $allowDeposit, isHighRiskToken: $isHighRiskToken, isEOS: $isEOS, tokenType: $tokenType, needAddressTag: $needAddressTag, needKycQuantity: $needKycQuantity, customOrder: $customOrder, baseTokenSymbols: $baseTokenSymbols, chainTypes: $chainTypes)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TokenModel'))
      ..add(DiagnosticsProperty('orgId', orgId))
      ..add(DiagnosticsProperty('tokenId', tokenId))
      ..add(DiagnosticsProperty('tokenName', tokenName))
      ..add(DiagnosticsProperty('tokenFullName', tokenFullName))
      ..add(DiagnosticsProperty('iconUrl', iconUrl))
      ..add(DiagnosticsProperty('allowWithdraw', allowWithdraw))
      ..add(DiagnosticsProperty('allowDeposit', allowDeposit))
      ..add(DiagnosticsProperty('isHighRiskToken', isHighRiskToken))
      ..add(DiagnosticsProperty('isEOS', isEOS))
      ..add(DiagnosticsProperty('tokenType', tokenType))
      ..add(DiagnosticsProperty('needAddressTag', needAddressTag))
      ..add(DiagnosticsProperty('needKycQuantity', needKycQuantity))
      ..add(DiagnosticsProperty('customOrder', customOrder))
      ..add(DiagnosticsProperty('baseTokenSymbols', baseTokenSymbols))
      ..add(DiagnosticsProperty('chainTypes', chainTypes));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TokenModelImpl &&
            (identical(other.orgId, orgId) || other.orgId == orgId) &&
            (identical(other.tokenId, tokenId) || other.tokenId == tokenId) &&
            (identical(other.tokenName, tokenName) ||
                other.tokenName == tokenName) &&
            (identical(other.tokenFullName, tokenFullName) ||
                other.tokenFullName == tokenFullName) &&
            (identical(other.iconUrl, iconUrl) || other.iconUrl == iconUrl) &&
            (identical(other.allowWithdraw, allowWithdraw) ||
                other.allowWithdraw == allowWithdraw) &&
            (identical(other.allowDeposit, allowDeposit) ||
                other.allowDeposit == allowDeposit) &&
            (identical(other.isHighRiskToken, isHighRiskToken) ||
                other.isHighRiskToken == isHighRiskToken) &&
            (identical(other.isEOS, isEOS) || other.isEOS == isEOS) &&
            (identical(other.tokenType, tokenType) ||
                other.tokenType == tokenType) &&
            (identical(other.needAddressTag, needAddressTag) ||
                other.needAddressTag == needAddressTag) &&
            (identical(other.needKycQuantity, needKycQuantity) ||
                other.needKycQuantity == needKycQuantity) &&
            (identical(other.customOrder, customOrder) ||
                other.customOrder == customOrder) &&
            const DeepCollectionEquality()
                .equals(other._baseTokenSymbols, _baseTokenSymbols) &&
            const DeepCollectionEquality()
                .equals(other._chainTypes, _chainTypes));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      orgId,
      tokenId,
      tokenName,
      tokenFullName,
      iconUrl,
      allowWithdraw,
      allowDeposit,
      isHighRiskToken,
      isEOS,
      tokenType,
      needAddressTag,
      needKycQuantity,
      customOrder,
      const DeepCollectionEquality().hash(_baseTokenSymbols),
      const DeepCollectionEquality().hash(_chainTypes));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TokenModelImplCopyWith<_$TokenModelImpl> get copyWith =>
      __$$TokenModelImplCopyWithImpl<_$TokenModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TokenModelImplToJson(
      this,
    );
  }
}

abstract class _TokenModel implements TokenModel {
  const factory _TokenModel(
      {final String? orgId,
      final String? tokenId,
      final String? tokenName,
      final String? tokenFullName,
      final String? iconUrl,
      final bool? allowWithdraw,
      final bool? allowDeposit,
      final bool? isHighRiskToken,
      final bool? isEOS,
      final String? tokenType,
      final bool? needAddressTag,
      final String? needKycQuantity,
      final int? customOrder,
      final List<SymbolModel>? baseTokenSymbols,
      final List<ChainTypesModel>? chainTypes}) = _$TokenModelImpl;

  factory _TokenModel.fromJson(Map<String, dynamic> json) =
      _$TokenModelImpl.fromJson;

  @override
  String? get orgId;
  @override
  String? get tokenId;
  @override
  String? get tokenName;
  @override
  String? get tokenFullName;
  @override
  String? get iconUrl;
  @override
  bool? get allowWithdraw;
  @override
  bool? get allowDeposit;
  @override
  bool? get isHighRiskToken;
  @override
  bool? get isEOS;
  @override
  String? get tokenType;
  @override
  bool? get needAddressTag;
  @override
  String? get needKycQuantity;
  @override
  int? get customOrder;
  @override
  List<SymbolModel>? get baseTokenSymbols;
  @override
  List<ChainTypesModel>? get chainTypes;
  @override
  @JsonKey(ignore: true)
  _$$TokenModelImplCopyWith<_$TokenModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

TokenInfoModel _$TokenInfoModelFromJson(Map<String, dynamic> json) {
  return _TokenInfoModel.fromJson(json);
}

/// @nodoc
mixin _$TokenInfoModel {
  String? get tokenId => throw _privateConstructorUsedError;
  String? get tokenName => throw _privateConstructorUsedError;
  String? get maxQuantitySupplied => throw _privateConstructorUsedError;
  String? get currentTurnover => throw _privateConstructorUsedError;
  String? get officialWebsiteUrl => throw _privateConstructorUsedError;
  String? get whitePaperUrl => throw _privateConstructorUsedError;
  String? get publishTime => throw _privateConstructorUsedError;
  String? get exploreUrl => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $TokenInfoModelCopyWith<TokenInfoModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TokenInfoModelCopyWith<$Res> {
  factory $TokenInfoModelCopyWith(
          TokenInfoModel value, $Res Function(TokenInfoModel) then) =
      _$TokenInfoModelCopyWithImpl<$Res, TokenInfoModel>;
  @useResult
  $Res call(
      {String? tokenId,
      String? tokenName,
      String? maxQuantitySupplied,
      String? currentTurnover,
      String? officialWebsiteUrl,
      String? whitePaperUrl,
      String? publishTime,
      String? exploreUrl,
      String? description});
}

/// @nodoc
class _$TokenInfoModelCopyWithImpl<$Res, $Val extends TokenInfoModel>
    implements $TokenInfoModelCopyWith<$Res> {
  _$TokenInfoModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tokenId = freezed,
    Object? tokenName = freezed,
    Object? maxQuantitySupplied = freezed,
    Object? currentTurnover = freezed,
    Object? officialWebsiteUrl = freezed,
    Object? whitePaperUrl = freezed,
    Object? publishTime = freezed,
    Object? exploreUrl = freezed,
    Object? description = freezed,
  }) {
    return _then(_value.copyWith(
      tokenId: freezed == tokenId
          ? _value.tokenId
          : tokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenName: freezed == tokenName
          ? _value.tokenName
          : tokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      maxQuantitySupplied: freezed == maxQuantitySupplied
          ? _value.maxQuantitySupplied
          : maxQuantitySupplied // ignore: cast_nullable_to_non_nullable
              as String?,
      currentTurnover: freezed == currentTurnover
          ? _value.currentTurnover
          : currentTurnover // ignore: cast_nullable_to_non_nullable
              as String?,
      officialWebsiteUrl: freezed == officialWebsiteUrl
          ? _value.officialWebsiteUrl
          : officialWebsiteUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      whitePaperUrl: freezed == whitePaperUrl
          ? _value.whitePaperUrl
          : whitePaperUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      publishTime: freezed == publishTime
          ? _value.publishTime
          : publishTime // ignore: cast_nullable_to_non_nullable
              as String?,
      exploreUrl: freezed == exploreUrl
          ? _value.exploreUrl
          : exploreUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TokenInfoModelImplCopyWith<$Res>
    implements $TokenInfoModelCopyWith<$Res> {
  factory _$$TokenInfoModelImplCopyWith(_$TokenInfoModelImpl value,
          $Res Function(_$TokenInfoModelImpl) then) =
      __$$TokenInfoModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? tokenId,
      String? tokenName,
      String? maxQuantitySupplied,
      String? currentTurnover,
      String? officialWebsiteUrl,
      String? whitePaperUrl,
      String? publishTime,
      String? exploreUrl,
      String? description});
}

/// @nodoc
class __$$TokenInfoModelImplCopyWithImpl<$Res>
    extends _$TokenInfoModelCopyWithImpl<$Res, _$TokenInfoModelImpl>
    implements _$$TokenInfoModelImplCopyWith<$Res> {
  __$$TokenInfoModelImplCopyWithImpl(
      _$TokenInfoModelImpl _value, $Res Function(_$TokenInfoModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tokenId = freezed,
    Object? tokenName = freezed,
    Object? maxQuantitySupplied = freezed,
    Object? currentTurnover = freezed,
    Object? officialWebsiteUrl = freezed,
    Object? whitePaperUrl = freezed,
    Object? publishTime = freezed,
    Object? exploreUrl = freezed,
    Object? description = freezed,
  }) {
    return _then(_$TokenInfoModelImpl(
      tokenId: freezed == tokenId
          ? _value.tokenId
          : tokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenName: freezed == tokenName
          ? _value.tokenName
          : tokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      maxQuantitySupplied: freezed == maxQuantitySupplied
          ? _value.maxQuantitySupplied
          : maxQuantitySupplied // ignore: cast_nullable_to_non_nullable
              as String?,
      currentTurnover: freezed == currentTurnover
          ? _value.currentTurnover
          : currentTurnover // ignore: cast_nullable_to_non_nullable
              as String?,
      officialWebsiteUrl: freezed == officialWebsiteUrl
          ? _value.officialWebsiteUrl
          : officialWebsiteUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      whitePaperUrl: freezed == whitePaperUrl
          ? _value.whitePaperUrl
          : whitePaperUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      publishTime: freezed == publishTime
          ? _value.publishTime
          : publishTime // ignore: cast_nullable_to_non_nullable
              as String?,
      exploreUrl: freezed == exploreUrl
          ? _value.exploreUrl
          : exploreUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TokenInfoModelImpl
    with DiagnosticableTreeMixin
    implements _TokenInfoModel {
  const _$TokenInfoModelImpl(
      {this.tokenId,
      this.tokenName,
      this.maxQuantitySupplied,
      this.currentTurnover,
      this.officialWebsiteUrl,
      this.whitePaperUrl,
      this.publishTime,
      this.exploreUrl,
      this.description});

  factory _$TokenInfoModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$TokenInfoModelImplFromJson(json);

  @override
  final String? tokenId;
  @override
  final String? tokenName;
  @override
  final String? maxQuantitySupplied;
  @override
  final String? currentTurnover;
  @override
  final String? officialWebsiteUrl;
  @override
  final String? whitePaperUrl;
  @override
  final String? publishTime;
  @override
  final String? exploreUrl;
  @override
  final String? description;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TokenInfoModel(tokenId: $tokenId, tokenName: $tokenName, maxQuantitySupplied: $maxQuantitySupplied, currentTurnover: $currentTurnover, officialWebsiteUrl: $officialWebsiteUrl, whitePaperUrl: $whitePaperUrl, publishTime: $publishTime, exploreUrl: $exploreUrl, description: $description)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TokenInfoModel'))
      ..add(DiagnosticsProperty('tokenId', tokenId))
      ..add(DiagnosticsProperty('tokenName', tokenName))
      ..add(DiagnosticsProperty('maxQuantitySupplied', maxQuantitySupplied))
      ..add(DiagnosticsProperty('currentTurnover', currentTurnover))
      ..add(DiagnosticsProperty('officialWebsiteUrl', officialWebsiteUrl))
      ..add(DiagnosticsProperty('whitePaperUrl', whitePaperUrl))
      ..add(DiagnosticsProperty('publishTime', publishTime))
      ..add(DiagnosticsProperty('exploreUrl', exploreUrl))
      ..add(DiagnosticsProperty('description', description));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TokenInfoModelImpl &&
            (identical(other.tokenId, tokenId) || other.tokenId == tokenId) &&
            (identical(other.tokenName, tokenName) ||
                other.tokenName == tokenName) &&
            (identical(other.maxQuantitySupplied, maxQuantitySupplied) ||
                other.maxQuantitySupplied == maxQuantitySupplied) &&
            (identical(other.currentTurnover, currentTurnover) ||
                other.currentTurnover == currentTurnover) &&
            (identical(other.officialWebsiteUrl, officialWebsiteUrl) ||
                other.officialWebsiteUrl == officialWebsiteUrl) &&
            (identical(other.whitePaperUrl, whitePaperUrl) ||
                other.whitePaperUrl == whitePaperUrl) &&
            (identical(other.publishTime, publishTime) ||
                other.publishTime == publishTime) &&
            (identical(other.exploreUrl, exploreUrl) ||
                other.exploreUrl == exploreUrl) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      tokenId,
      tokenName,
      maxQuantitySupplied,
      currentTurnover,
      officialWebsiteUrl,
      whitePaperUrl,
      publishTime,
      exploreUrl,
      description);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TokenInfoModelImplCopyWith<_$TokenInfoModelImpl> get copyWith =>
      __$$TokenInfoModelImplCopyWithImpl<_$TokenInfoModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TokenInfoModelImplToJson(
      this,
    );
  }
}

abstract class _TokenInfoModel implements TokenInfoModel {
  const factory _TokenInfoModel(
      {final String? tokenId,
      final String? tokenName,
      final String? maxQuantitySupplied,
      final String? currentTurnover,
      final String? officialWebsiteUrl,
      final String? whitePaperUrl,
      final String? publishTime,
      final String? exploreUrl,
      final String? description}) = _$TokenInfoModelImpl;

  factory _TokenInfoModel.fromJson(Map<String, dynamic> json) =
      _$TokenInfoModelImpl.fromJson;

  @override
  String? get tokenId;
  @override
  String? get tokenName;
  @override
  String? get maxQuantitySupplied;
  @override
  String? get currentTurnover;
  @override
  String? get officialWebsiteUrl;
  @override
  String? get whitePaperUrl;
  @override
  String? get publishTime;
  @override
  String? get exploreUrl;
  @override
  String? get description;
  @override
  @JsonKey(ignore: true)
  _$$TokenInfoModelImplCopyWith<_$TokenInfoModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ChainTypesModel _$ChainTypesModelFromJson(Map<String, dynamic> json) {
  return _ChainTypesModel.fromJson(json);
}

/// @nodoc
mixin _$ChainTypesModel {
  String? get chainType => throw _privateConstructorUsedError;
  bool? get allowDeposit => throw _privateConstructorUsedError;
  bool? get allowWithdraw => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChainTypesModelCopyWith<ChainTypesModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChainTypesModelCopyWith<$Res> {
  factory $ChainTypesModelCopyWith(
          ChainTypesModel value, $Res Function(ChainTypesModel) then) =
      _$ChainTypesModelCopyWithImpl<$Res, ChainTypesModel>;
  @useResult
  $Res call({String? chainType, bool? allowDeposit, bool? allowWithdraw});
}

/// @nodoc
class _$ChainTypesModelCopyWithImpl<$Res, $Val extends ChainTypesModel>
    implements $ChainTypesModelCopyWith<$Res> {
  _$ChainTypesModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chainType = freezed,
    Object? allowDeposit = freezed,
    Object? allowWithdraw = freezed,
  }) {
    return _then(_value.copyWith(
      chainType: freezed == chainType
          ? _value.chainType
          : chainType // ignore: cast_nullable_to_non_nullable
              as String?,
      allowDeposit: freezed == allowDeposit
          ? _value.allowDeposit
          : allowDeposit // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowWithdraw: freezed == allowWithdraw
          ? _value.allowWithdraw
          : allowWithdraw // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChainTypesModelImplCopyWith<$Res>
    implements $ChainTypesModelCopyWith<$Res> {
  factory _$$ChainTypesModelImplCopyWith(_$ChainTypesModelImpl value,
          $Res Function(_$ChainTypesModelImpl) then) =
      __$$ChainTypesModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? chainType, bool? allowDeposit, bool? allowWithdraw});
}

/// @nodoc
class __$$ChainTypesModelImplCopyWithImpl<$Res>
    extends _$ChainTypesModelCopyWithImpl<$Res, _$ChainTypesModelImpl>
    implements _$$ChainTypesModelImplCopyWith<$Res> {
  __$$ChainTypesModelImplCopyWithImpl(
      _$ChainTypesModelImpl _value, $Res Function(_$ChainTypesModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chainType = freezed,
    Object? allowDeposit = freezed,
    Object? allowWithdraw = freezed,
  }) {
    return _then(_$ChainTypesModelImpl(
      chainType: freezed == chainType
          ? _value.chainType
          : chainType // ignore: cast_nullable_to_non_nullable
              as String?,
      allowDeposit: freezed == allowDeposit
          ? _value.allowDeposit
          : allowDeposit // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowWithdraw: freezed == allowWithdraw
          ? _value.allowWithdraw
          : allowWithdraw // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChainTypesModelImpl
    with DiagnosticableTreeMixin
    implements _ChainTypesModel {
  const _$ChainTypesModelImpl(
      {this.chainType, this.allowDeposit, this.allowWithdraw});

  factory _$ChainTypesModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChainTypesModelImplFromJson(json);

  @override
  final String? chainType;
  @override
  final bool? allowDeposit;
  @override
  final bool? allowWithdraw;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChainTypesModel(chainType: $chainType, allowDeposit: $allowDeposit, allowWithdraw: $allowWithdraw)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChainTypesModel'))
      ..add(DiagnosticsProperty('chainType', chainType))
      ..add(DiagnosticsProperty('allowDeposit', allowDeposit))
      ..add(DiagnosticsProperty('allowWithdraw', allowWithdraw));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChainTypesModelImpl &&
            (identical(other.chainType, chainType) ||
                other.chainType == chainType) &&
            (identical(other.allowDeposit, allowDeposit) ||
                other.allowDeposit == allowDeposit) &&
            (identical(other.allowWithdraw, allowWithdraw) ||
                other.allowWithdraw == allowWithdraw));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, chainType, allowDeposit, allowWithdraw);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChainTypesModelImplCopyWith<_$ChainTypesModelImpl> get copyWith =>
      __$$ChainTypesModelImplCopyWithImpl<_$ChainTypesModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChainTypesModelImplToJson(
      this,
    );
  }
}

abstract class _ChainTypesModel implements ChainTypesModel {
  const factory _ChainTypesModel(
      {final String? chainType,
      final bool? allowDeposit,
      final bool? allowWithdraw}) = _$ChainTypesModelImpl;

  factory _ChainTypesModel.fromJson(Map<String, dynamic> json) =
      _$ChainTypesModelImpl.fromJson;

  @override
  String? get chainType;
  @override
  bool? get allowDeposit;
  @override
  bool? get allowWithdraw;
  @override
  @JsonKey(ignore: true)
  _$$ChainTypesModelImplCopyWith<_$ChainTypesModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
