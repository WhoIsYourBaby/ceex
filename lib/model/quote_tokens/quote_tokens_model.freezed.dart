// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'quote_tokens_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

QuoteTokensModel _$QuoteTokensModelFromJson(Map<String, dynamic> json) {
  return _QuoteTokensModel.fromJson(json);
}

/// @nodoc
mixin _$QuoteTokensModel {
  int? get addressCount => throw _privateConstructorUsedError;
  bool? get allowDeposit => throw _privateConstructorUsedError;
  bool? get allowWithdraw => throw _privateConstructorUsedError;
  List<BaseTokenSymbolsModel> get baseTokenSymbols =>
      throw _privateConstructorUsedError;
  List<ChainTypeModel>? get chainTypes => throw _privateConstructorUsedError;
  int? get customOrder => throw _privateConstructorUsedError;
  String? get iconUrl => throw _privateConstructorUsedError;
  bool? get isEOS => throw _privateConstructorUsedError;
  bool? get isHighRiskToken => throw _privateConstructorUsedError;
  bool? get needAddressTag => throw _privateConstructorUsedError;
  String? get needKycQuantity => throw _privateConstructorUsedError;
  String? get orgId => throw _privateConstructorUsedError;
  String? get tokenFullName => throw _privateConstructorUsedError;
  String? get tokenId => throw _privateConstructorUsedError;
  String? get tokenName => throw _privateConstructorUsedError;
  String? get tokenType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $QuoteTokensModelCopyWith<QuoteTokensModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $QuoteTokensModelCopyWith<$Res> {
  factory $QuoteTokensModelCopyWith(
          QuoteTokensModel value, $Res Function(QuoteTokensModel) then) =
      _$QuoteTokensModelCopyWithImpl<$Res, QuoteTokensModel>;
  @useResult
  $Res call(
      {int? addressCount,
      bool? allowDeposit,
      bool? allowWithdraw,
      List<BaseTokenSymbolsModel> baseTokenSymbols,
      List<ChainTypeModel>? chainTypes,
      int? customOrder,
      String? iconUrl,
      bool? isEOS,
      bool? isHighRiskToken,
      bool? needAddressTag,
      String? needKycQuantity,
      String? orgId,
      String? tokenFullName,
      String? tokenId,
      String? tokenName,
      String? tokenType});
}

/// @nodoc
class _$QuoteTokensModelCopyWithImpl<$Res, $Val extends QuoteTokensModel>
    implements $QuoteTokensModelCopyWith<$Res> {
  _$QuoteTokensModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addressCount = freezed,
    Object? allowDeposit = freezed,
    Object? allowWithdraw = freezed,
    Object? baseTokenSymbols = null,
    Object? chainTypes = freezed,
    Object? customOrder = freezed,
    Object? iconUrl = freezed,
    Object? isEOS = freezed,
    Object? isHighRiskToken = freezed,
    Object? needAddressTag = freezed,
    Object? needKycQuantity = freezed,
    Object? orgId = freezed,
    Object? tokenFullName = freezed,
    Object? tokenId = freezed,
    Object? tokenName = freezed,
    Object? tokenType = freezed,
  }) {
    return _then(_value.copyWith(
      addressCount: freezed == addressCount
          ? _value.addressCount
          : addressCount // ignore: cast_nullable_to_non_nullable
              as int?,
      allowDeposit: freezed == allowDeposit
          ? _value.allowDeposit
          : allowDeposit // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowWithdraw: freezed == allowWithdraw
          ? _value.allowWithdraw
          : allowWithdraw // ignore: cast_nullable_to_non_nullable
              as bool?,
      baseTokenSymbols: null == baseTokenSymbols
          ? _value.baseTokenSymbols
          : baseTokenSymbols // ignore: cast_nullable_to_non_nullable
              as List<BaseTokenSymbolsModel>,
      chainTypes: freezed == chainTypes
          ? _value.chainTypes
          : chainTypes // ignore: cast_nullable_to_non_nullable
              as List<ChainTypeModel>?,
      customOrder: freezed == customOrder
          ? _value.customOrder
          : customOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      iconUrl: freezed == iconUrl
          ? _value.iconUrl
          : iconUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      isEOS: freezed == isEOS
          ? _value.isEOS
          : isEOS // ignore: cast_nullable_to_non_nullable
              as bool?,
      isHighRiskToken: freezed == isHighRiskToken
          ? _value.isHighRiskToken
          : isHighRiskToken // ignore: cast_nullable_to_non_nullable
              as bool?,
      needAddressTag: freezed == needAddressTag
          ? _value.needAddressTag
          : needAddressTag // ignore: cast_nullable_to_non_nullable
              as bool?,
      needKycQuantity: freezed == needKycQuantity
          ? _value.needKycQuantity
          : needKycQuantity // ignore: cast_nullable_to_non_nullable
              as String?,
      orgId: freezed == orgId
          ? _value.orgId
          : orgId // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenFullName: freezed == tokenFullName
          ? _value.tokenFullName
          : tokenFullName // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenId: freezed == tokenId
          ? _value.tokenId
          : tokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenName: freezed == tokenName
          ? _value.tokenName
          : tokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenType: freezed == tokenType
          ? _value.tokenType
          : tokenType // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$QuoteTokensModelImplCopyWith<$Res>
    implements $QuoteTokensModelCopyWith<$Res> {
  factory _$$QuoteTokensModelImplCopyWith(_$QuoteTokensModelImpl value,
          $Res Function(_$QuoteTokensModelImpl) then) =
      __$$QuoteTokensModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? addressCount,
      bool? allowDeposit,
      bool? allowWithdraw,
      List<BaseTokenSymbolsModel> baseTokenSymbols,
      List<ChainTypeModel>? chainTypes,
      int? customOrder,
      String? iconUrl,
      bool? isEOS,
      bool? isHighRiskToken,
      bool? needAddressTag,
      String? needKycQuantity,
      String? orgId,
      String? tokenFullName,
      String? tokenId,
      String? tokenName,
      String? tokenType});
}

/// @nodoc
class __$$QuoteTokensModelImplCopyWithImpl<$Res>
    extends _$QuoteTokensModelCopyWithImpl<$Res, _$QuoteTokensModelImpl>
    implements _$$QuoteTokensModelImplCopyWith<$Res> {
  __$$QuoteTokensModelImplCopyWithImpl(_$QuoteTokensModelImpl _value,
      $Res Function(_$QuoteTokensModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? addressCount = freezed,
    Object? allowDeposit = freezed,
    Object? allowWithdraw = freezed,
    Object? baseTokenSymbols = null,
    Object? chainTypes = freezed,
    Object? customOrder = freezed,
    Object? iconUrl = freezed,
    Object? isEOS = freezed,
    Object? isHighRiskToken = freezed,
    Object? needAddressTag = freezed,
    Object? needKycQuantity = freezed,
    Object? orgId = freezed,
    Object? tokenFullName = freezed,
    Object? tokenId = freezed,
    Object? tokenName = freezed,
    Object? tokenType = freezed,
  }) {
    return _then(_$QuoteTokensModelImpl(
      addressCount: freezed == addressCount
          ? _value.addressCount
          : addressCount // ignore: cast_nullable_to_non_nullable
              as int?,
      allowDeposit: freezed == allowDeposit
          ? _value.allowDeposit
          : allowDeposit // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowWithdraw: freezed == allowWithdraw
          ? _value.allowWithdraw
          : allowWithdraw // ignore: cast_nullable_to_non_nullable
              as bool?,
      baseTokenSymbols: null == baseTokenSymbols
          ? _value._baseTokenSymbols
          : baseTokenSymbols // ignore: cast_nullable_to_non_nullable
              as List<BaseTokenSymbolsModel>,
      chainTypes: freezed == chainTypes
          ? _value._chainTypes
          : chainTypes // ignore: cast_nullable_to_non_nullable
              as List<ChainTypeModel>?,
      customOrder: freezed == customOrder
          ? _value.customOrder
          : customOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      iconUrl: freezed == iconUrl
          ? _value.iconUrl
          : iconUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      isEOS: freezed == isEOS
          ? _value.isEOS
          : isEOS // ignore: cast_nullable_to_non_nullable
              as bool?,
      isHighRiskToken: freezed == isHighRiskToken
          ? _value.isHighRiskToken
          : isHighRiskToken // ignore: cast_nullable_to_non_nullable
              as bool?,
      needAddressTag: freezed == needAddressTag
          ? _value.needAddressTag
          : needAddressTag // ignore: cast_nullable_to_non_nullable
              as bool?,
      needKycQuantity: freezed == needKycQuantity
          ? _value.needKycQuantity
          : needKycQuantity // ignore: cast_nullable_to_non_nullable
              as String?,
      orgId: freezed == orgId
          ? _value.orgId
          : orgId // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenFullName: freezed == tokenFullName
          ? _value.tokenFullName
          : tokenFullName // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenId: freezed == tokenId
          ? _value.tokenId
          : tokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenName: freezed == tokenName
          ? _value.tokenName
          : tokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      tokenType: freezed == tokenType
          ? _value.tokenType
          : tokenType // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$QuoteTokensModelImpl
    with DiagnosticableTreeMixin
    implements _QuoteTokensModel {
  const _$QuoteTokensModelImpl(
      {required this.addressCount,
      required this.allowDeposit,
      required this.allowWithdraw,
      required final List<BaseTokenSymbolsModel> baseTokenSymbols,
      required final List<ChainTypeModel>? chainTypes,
      required this.customOrder,
      required this.iconUrl,
      required this.isEOS,
      required this.isHighRiskToken,
      required this.needAddressTag,
      required this.needKycQuantity,
      required this.orgId,
      required this.tokenFullName,
      required this.tokenId,
      required this.tokenName,
      required this.tokenType})
      : _baseTokenSymbols = baseTokenSymbols,
        _chainTypes = chainTypes;

  factory _$QuoteTokensModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$QuoteTokensModelImplFromJson(json);

  @override
  final int? addressCount;
  @override
  final bool? allowDeposit;
  @override
  final bool? allowWithdraw;
  final List<BaseTokenSymbolsModel> _baseTokenSymbols;
  @override
  List<BaseTokenSymbolsModel> get baseTokenSymbols {
    if (_baseTokenSymbols is EqualUnmodifiableListView)
      return _baseTokenSymbols;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_baseTokenSymbols);
  }

  final List<ChainTypeModel>? _chainTypes;
  @override
  List<ChainTypeModel>? get chainTypes {
    final value = _chainTypes;
    if (value == null) return null;
    if (_chainTypes is EqualUnmodifiableListView) return _chainTypes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final int? customOrder;
  @override
  final String? iconUrl;
  @override
  final bool? isEOS;
  @override
  final bool? isHighRiskToken;
  @override
  final bool? needAddressTag;
  @override
  final String? needKycQuantity;
  @override
  final String? orgId;
  @override
  final String? tokenFullName;
  @override
  final String? tokenId;
  @override
  final String? tokenName;
  @override
  final String? tokenType;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'QuoteTokensModel(addressCount: $addressCount, allowDeposit: $allowDeposit, allowWithdraw: $allowWithdraw, baseTokenSymbols: $baseTokenSymbols, chainTypes: $chainTypes, customOrder: $customOrder, iconUrl: $iconUrl, isEOS: $isEOS, isHighRiskToken: $isHighRiskToken, needAddressTag: $needAddressTag, needKycQuantity: $needKycQuantity, orgId: $orgId, tokenFullName: $tokenFullName, tokenId: $tokenId, tokenName: $tokenName, tokenType: $tokenType)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'QuoteTokensModel'))
      ..add(DiagnosticsProperty('addressCount', addressCount))
      ..add(DiagnosticsProperty('allowDeposit', allowDeposit))
      ..add(DiagnosticsProperty('allowWithdraw', allowWithdraw))
      ..add(DiagnosticsProperty('baseTokenSymbols', baseTokenSymbols))
      ..add(DiagnosticsProperty('chainTypes', chainTypes))
      ..add(DiagnosticsProperty('customOrder', customOrder))
      ..add(DiagnosticsProperty('iconUrl', iconUrl))
      ..add(DiagnosticsProperty('isEOS', isEOS))
      ..add(DiagnosticsProperty('isHighRiskToken', isHighRiskToken))
      ..add(DiagnosticsProperty('needAddressTag', needAddressTag))
      ..add(DiagnosticsProperty('needKycQuantity', needKycQuantity))
      ..add(DiagnosticsProperty('orgId', orgId))
      ..add(DiagnosticsProperty('tokenFullName', tokenFullName))
      ..add(DiagnosticsProperty('tokenId', tokenId))
      ..add(DiagnosticsProperty('tokenName', tokenName))
      ..add(DiagnosticsProperty('tokenType', tokenType));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$QuoteTokensModelImpl &&
            (identical(other.addressCount, addressCount) ||
                other.addressCount == addressCount) &&
            (identical(other.allowDeposit, allowDeposit) ||
                other.allowDeposit == allowDeposit) &&
            (identical(other.allowWithdraw, allowWithdraw) ||
                other.allowWithdraw == allowWithdraw) &&
            const DeepCollectionEquality()
                .equals(other._baseTokenSymbols, _baseTokenSymbols) &&
            const DeepCollectionEquality()
                .equals(other._chainTypes, _chainTypes) &&
            (identical(other.customOrder, customOrder) ||
                other.customOrder == customOrder) &&
            (identical(other.iconUrl, iconUrl) || other.iconUrl == iconUrl) &&
            (identical(other.isEOS, isEOS) || other.isEOS == isEOS) &&
            (identical(other.isHighRiskToken, isHighRiskToken) ||
                other.isHighRiskToken == isHighRiskToken) &&
            (identical(other.needAddressTag, needAddressTag) ||
                other.needAddressTag == needAddressTag) &&
            (identical(other.needKycQuantity, needKycQuantity) ||
                other.needKycQuantity == needKycQuantity) &&
            (identical(other.orgId, orgId) || other.orgId == orgId) &&
            (identical(other.tokenFullName, tokenFullName) ||
                other.tokenFullName == tokenFullName) &&
            (identical(other.tokenId, tokenId) || other.tokenId == tokenId) &&
            (identical(other.tokenName, tokenName) ||
                other.tokenName == tokenName) &&
            (identical(other.tokenType, tokenType) ||
                other.tokenType == tokenType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      addressCount,
      allowDeposit,
      allowWithdraw,
      const DeepCollectionEquality().hash(_baseTokenSymbols),
      const DeepCollectionEquality().hash(_chainTypes),
      customOrder,
      iconUrl,
      isEOS,
      isHighRiskToken,
      needAddressTag,
      needKycQuantity,
      orgId,
      tokenFullName,
      tokenId,
      tokenName,
      tokenType);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$QuoteTokensModelImplCopyWith<_$QuoteTokensModelImpl> get copyWith =>
      __$$QuoteTokensModelImplCopyWithImpl<_$QuoteTokensModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$QuoteTokensModelImplToJson(
      this,
    );
  }
}

abstract class _QuoteTokensModel implements QuoteTokensModel {
  const factory _QuoteTokensModel(
      {required final int? addressCount,
      required final bool? allowDeposit,
      required final bool? allowWithdraw,
      required final List<BaseTokenSymbolsModel> baseTokenSymbols,
      required final List<ChainTypeModel>? chainTypes,
      required final int? customOrder,
      required final String? iconUrl,
      required final bool? isEOS,
      required final bool? isHighRiskToken,
      required final bool? needAddressTag,
      required final String? needKycQuantity,
      required final String? orgId,
      required final String? tokenFullName,
      required final String? tokenId,
      required final String? tokenName,
      required final String? tokenType}) = _$QuoteTokensModelImpl;

  factory _QuoteTokensModel.fromJson(Map<String, dynamic> json) =
      _$QuoteTokensModelImpl.fromJson;

  @override
  int? get addressCount;
  @override
  bool? get allowDeposit;
  @override
  bool? get allowWithdraw;
  @override
  List<BaseTokenSymbolsModel> get baseTokenSymbols;
  @override
  List<ChainTypeModel>? get chainTypes;
  @override
  int? get customOrder;
  @override
  String? get iconUrl;
  @override
  bool? get isEOS;
  @override
  bool? get isHighRiskToken;
  @override
  bool? get needAddressTag;
  @override
  String? get needKycQuantity;
  @override
  String? get orgId;
  @override
  String? get tokenFullName;
  @override
  String? get tokenId;
  @override
  String? get tokenName;
  @override
  String? get tokenType;
  @override
  @JsonKey(ignore: true)
  _$$QuoteTokensModelImplCopyWith<_$QuoteTokensModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

BaseTokenSymbolsModel _$BaseTokenSymbolsModelFromJson(
    Map<String, dynamic> json) {
  return _BaseTokenSymbolsModel.fromJson(json);
}

/// @nodoc
mixin _$BaseTokenSymbolsModel {
  bool? get allowMargin => throw _privateConstructorUsedError;
  bool? get allowPlan => throw _privateConstructorUsedError;
  int? get amountDigit => throw _privateConstructorUsedError;
  int? get baseDigit => throw _privateConstructorUsedError;
  String? get basePrecision => throw _privateConstructorUsedError;
  String? get baseTokenId => throw _privateConstructorUsedError;
  String? get baseTokenName => throw _privateConstructorUsedError;
  bool? get buyMode => throw _privateConstructorUsedError;
  bool? get canTrade => throw _privateConstructorUsedError;
  int? get category => throw _privateConstructorUsedError;
  int? get coinType => throw _privateConstructorUsedError;
  int? get customOrder => throw _privateConstructorUsedError;
  String? get digitMerge => throw _privateConstructorUsedError;
  String? get exchangeId => throw _privateConstructorUsedError;
  bool? get favorite => throw _privateConstructorUsedError;
  int? get indexRecommendOrder => throw _privateConstructorUsedError;
  bool? get isNeedSwitchTradeTab => throw _privateConstructorUsedError;
  bool? get isReverse => throw _privateConstructorUsedError;
  int? get itemShowType => throw _privateConstructorUsedError;
  String? get labelId => throw _privateConstructorUsedError;
  String? get minPricePrecision => throw _privateConstructorUsedError;
  String? get minTradeAmount => throw _privateConstructorUsedError;
  String? get minTradeQuantity => throw _privateConstructorUsedError;
  bool? get openStatus => throw _privateConstructorUsedError;
  String? get orgId => throw _privateConstructorUsedError;
  int? get priceDigit => throw _privateConstructorUsedError;
  String? get quotePrecision => throw _privateConstructorUsedError;
  String? get quoteTokenId => throw _privateConstructorUsedError;
  String? get quoteTokenName => throw _privateConstructorUsedError;
  bool? get select => throw _privateConstructorUsedError;
  bool? get showStatus => throw _privateConstructorUsedError;
  String? get symbolId => throw _privateConstructorUsedError;
  String? get symbolName => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $BaseTokenSymbolsModelCopyWith<BaseTokenSymbolsModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BaseTokenSymbolsModelCopyWith<$Res> {
  factory $BaseTokenSymbolsModelCopyWith(BaseTokenSymbolsModel value,
          $Res Function(BaseTokenSymbolsModel) then) =
      _$BaseTokenSymbolsModelCopyWithImpl<$Res, BaseTokenSymbolsModel>;
  @useResult
  $Res call(
      {bool? allowMargin,
      bool? allowPlan,
      int? amountDigit,
      int? baseDigit,
      String? basePrecision,
      String? baseTokenId,
      String? baseTokenName,
      bool? buyMode,
      bool? canTrade,
      int? category,
      int? coinType,
      int? customOrder,
      String? digitMerge,
      String? exchangeId,
      bool? favorite,
      int? indexRecommendOrder,
      bool? isNeedSwitchTradeTab,
      bool? isReverse,
      int? itemShowType,
      String? labelId,
      String? minPricePrecision,
      String? minTradeAmount,
      String? minTradeQuantity,
      bool? openStatus,
      String? orgId,
      int? priceDigit,
      String? quotePrecision,
      String? quoteTokenId,
      String? quoteTokenName,
      bool? select,
      bool? showStatus,
      String? symbolId,
      String? symbolName});
}

/// @nodoc
class _$BaseTokenSymbolsModelCopyWithImpl<$Res,
        $Val extends BaseTokenSymbolsModel>
    implements $BaseTokenSymbolsModelCopyWith<$Res> {
  _$BaseTokenSymbolsModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allowMargin = freezed,
    Object? allowPlan = freezed,
    Object? amountDigit = freezed,
    Object? baseDigit = freezed,
    Object? basePrecision = freezed,
    Object? baseTokenId = freezed,
    Object? baseTokenName = freezed,
    Object? buyMode = freezed,
    Object? canTrade = freezed,
    Object? category = freezed,
    Object? coinType = freezed,
    Object? customOrder = freezed,
    Object? digitMerge = freezed,
    Object? exchangeId = freezed,
    Object? favorite = freezed,
    Object? indexRecommendOrder = freezed,
    Object? isNeedSwitchTradeTab = freezed,
    Object? isReverse = freezed,
    Object? itemShowType = freezed,
    Object? labelId = freezed,
    Object? minPricePrecision = freezed,
    Object? minTradeAmount = freezed,
    Object? minTradeQuantity = freezed,
    Object? openStatus = freezed,
    Object? orgId = freezed,
    Object? priceDigit = freezed,
    Object? quotePrecision = freezed,
    Object? quoteTokenId = freezed,
    Object? quoteTokenName = freezed,
    Object? select = freezed,
    Object? showStatus = freezed,
    Object? symbolId = freezed,
    Object? symbolName = freezed,
  }) {
    return _then(_value.copyWith(
      allowMargin: freezed == allowMargin
          ? _value.allowMargin
          : allowMargin // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowPlan: freezed == allowPlan
          ? _value.allowPlan
          : allowPlan // ignore: cast_nullable_to_non_nullable
              as bool?,
      amountDigit: freezed == amountDigit
          ? _value.amountDigit
          : amountDigit // ignore: cast_nullable_to_non_nullable
              as int?,
      baseDigit: freezed == baseDigit
          ? _value.baseDigit
          : baseDigit // ignore: cast_nullable_to_non_nullable
              as int?,
      basePrecision: freezed == basePrecision
          ? _value.basePrecision
          : basePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      baseTokenId: freezed == baseTokenId
          ? _value.baseTokenId
          : baseTokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      baseTokenName: freezed == baseTokenName
          ? _value.baseTokenName
          : baseTokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      buyMode: freezed == buyMode
          ? _value.buyMode
          : buyMode // ignore: cast_nullable_to_non_nullable
              as bool?,
      canTrade: freezed == canTrade
          ? _value.canTrade
          : canTrade // ignore: cast_nullable_to_non_nullable
              as bool?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as int?,
      coinType: freezed == coinType
          ? _value.coinType
          : coinType // ignore: cast_nullable_to_non_nullable
              as int?,
      customOrder: freezed == customOrder
          ? _value.customOrder
          : customOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      digitMerge: freezed == digitMerge
          ? _value.digitMerge
          : digitMerge // ignore: cast_nullable_to_non_nullable
              as String?,
      exchangeId: freezed == exchangeId
          ? _value.exchangeId
          : exchangeId // ignore: cast_nullable_to_non_nullable
              as String?,
      favorite: freezed == favorite
          ? _value.favorite
          : favorite // ignore: cast_nullable_to_non_nullable
              as bool?,
      indexRecommendOrder: freezed == indexRecommendOrder
          ? _value.indexRecommendOrder
          : indexRecommendOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      isNeedSwitchTradeTab: freezed == isNeedSwitchTradeTab
          ? _value.isNeedSwitchTradeTab
          : isNeedSwitchTradeTab // ignore: cast_nullable_to_non_nullable
              as bool?,
      isReverse: freezed == isReverse
          ? _value.isReverse
          : isReverse // ignore: cast_nullable_to_non_nullable
              as bool?,
      itemShowType: freezed == itemShowType
          ? _value.itemShowType
          : itemShowType // ignore: cast_nullable_to_non_nullable
              as int?,
      labelId: freezed == labelId
          ? _value.labelId
          : labelId // ignore: cast_nullable_to_non_nullable
              as String?,
      minPricePrecision: freezed == minPricePrecision
          ? _value.minPricePrecision
          : minPricePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      minTradeAmount: freezed == minTradeAmount
          ? _value.minTradeAmount
          : minTradeAmount // ignore: cast_nullable_to_non_nullable
              as String?,
      minTradeQuantity: freezed == minTradeQuantity
          ? _value.minTradeQuantity
          : minTradeQuantity // ignore: cast_nullable_to_non_nullable
              as String?,
      openStatus: freezed == openStatus
          ? _value.openStatus
          : openStatus // ignore: cast_nullable_to_non_nullable
              as bool?,
      orgId: freezed == orgId
          ? _value.orgId
          : orgId // ignore: cast_nullable_to_non_nullable
              as String?,
      priceDigit: freezed == priceDigit
          ? _value.priceDigit
          : priceDigit // ignore: cast_nullable_to_non_nullable
              as int?,
      quotePrecision: freezed == quotePrecision
          ? _value.quotePrecision
          : quotePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      quoteTokenId: freezed == quoteTokenId
          ? _value.quoteTokenId
          : quoteTokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      quoteTokenName: freezed == quoteTokenName
          ? _value.quoteTokenName
          : quoteTokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      select: freezed == select
          ? _value.select
          : select // ignore: cast_nullable_to_non_nullable
              as bool?,
      showStatus: freezed == showStatus
          ? _value.showStatus
          : showStatus // ignore: cast_nullable_to_non_nullable
              as bool?,
      symbolId: freezed == symbolId
          ? _value.symbolId
          : symbolId // ignore: cast_nullable_to_non_nullable
              as String?,
      symbolName: freezed == symbolName
          ? _value.symbolName
          : symbolName // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BaseTokenSymbolsModelImplCopyWith<$Res>
    implements $BaseTokenSymbolsModelCopyWith<$Res> {
  factory _$$BaseTokenSymbolsModelImplCopyWith(
          _$BaseTokenSymbolsModelImpl value,
          $Res Function(_$BaseTokenSymbolsModelImpl) then) =
      __$$BaseTokenSymbolsModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool? allowMargin,
      bool? allowPlan,
      int? amountDigit,
      int? baseDigit,
      String? basePrecision,
      String? baseTokenId,
      String? baseTokenName,
      bool? buyMode,
      bool? canTrade,
      int? category,
      int? coinType,
      int? customOrder,
      String? digitMerge,
      String? exchangeId,
      bool? favorite,
      int? indexRecommendOrder,
      bool? isNeedSwitchTradeTab,
      bool? isReverse,
      int? itemShowType,
      String? labelId,
      String? minPricePrecision,
      String? minTradeAmount,
      String? minTradeQuantity,
      bool? openStatus,
      String? orgId,
      int? priceDigit,
      String? quotePrecision,
      String? quoteTokenId,
      String? quoteTokenName,
      bool? select,
      bool? showStatus,
      String? symbolId,
      String? symbolName});
}

/// @nodoc
class __$$BaseTokenSymbolsModelImplCopyWithImpl<$Res>
    extends _$BaseTokenSymbolsModelCopyWithImpl<$Res,
        _$BaseTokenSymbolsModelImpl>
    implements _$$BaseTokenSymbolsModelImplCopyWith<$Res> {
  __$$BaseTokenSymbolsModelImplCopyWithImpl(_$BaseTokenSymbolsModelImpl _value,
      $Res Function(_$BaseTokenSymbolsModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? allowMargin = freezed,
    Object? allowPlan = freezed,
    Object? amountDigit = freezed,
    Object? baseDigit = freezed,
    Object? basePrecision = freezed,
    Object? baseTokenId = freezed,
    Object? baseTokenName = freezed,
    Object? buyMode = freezed,
    Object? canTrade = freezed,
    Object? category = freezed,
    Object? coinType = freezed,
    Object? customOrder = freezed,
    Object? digitMerge = freezed,
    Object? exchangeId = freezed,
    Object? favorite = freezed,
    Object? indexRecommendOrder = freezed,
    Object? isNeedSwitchTradeTab = freezed,
    Object? isReverse = freezed,
    Object? itemShowType = freezed,
    Object? labelId = freezed,
    Object? minPricePrecision = freezed,
    Object? minTradeAmount = freezed,
    Object? minTradeQuantity = freezed,
    Object? openStatus = freezed,
    Object? orgId = freezed,
    Object? priceDigit = freezed,
    Object? quotePrecision = freezed,
    Object? quoteTokenId = freezed,
    Object? quoteTokenName = freezed,
    Object? select = freezed,
    Object? showStatus = freezed,
    Object? symbolId = freezed,
    Object? symbolName = freezed,
  }) {
    return _then(_$BaseTokenSymbolsModelImpl(
      allowMargin: freezed == allowMargin
          ? _value.allowMargin
          : allowMargin // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowPlan: freezed == allowPlan
          ? _value.allowPlan
          : allowPlan // ignore: cast_nullable_to_non_nullable
              as bool?,
      amountDigit: freezed == amountDigit
          ? _value.amountDigit
          : amountDigit // ignore: cast_nullable_to_non_nullable
              as int?,
      baseDigit: freezed == baseDigit
          ? _value.baseDigit
          : baseDigit // ignore: cast_nullable_to_non_nullable
              as int?,
      basePrecision: freezed == basePrecision
          ? _value.basePrecision
          : basePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      baseTokenId: freezed == baseTokenId
          ? _value.baseTokenId
          : baseTokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      baseTokenName: freezed == baseTokenName
          ? _value.baseTokenName
          : baseTokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      buyMode: freezed == buyMode
          ? _value.buyMode
          : buyMode // ignore: cast_nullable_to_non_nullable
              as bool?,
      canTrade: freezed == canTrade
          ? _value.canTrade
          : canTrade // ignore: cast_nullable_to_non_nullable
              as bool?,
      category: freezed == category
          ? _value.category
          : category // ignore: cast_nullable_to_non_nullable
              as int?,
      coinType: freezed == coinType
          ? _value.coinType
          : coinType // ignore: cast_nullable_to_non_nullable
              as int?,
      customOrder: freezed == customOrder
          ? _value.customOrder
          : customOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      digitMerge: freezed == digitMerge
          ? _value.digitMerge
          : digitMerge // ignore: cast_nullable_to_non_nullable
              as String?,
      exchangeId: freezed == exchangeId
          ? _value.exchangeId
          : exchangeId // ignore: cast_nullable_to_non_nullable
              as String?,
      favorite: freezed == favorite
          ? _value.favorite
          : favorite // ignore: cast_nullable_to_non_nullable
              as bool?,
      indexRecommendOrder: freezed == indexRecommendOrder
          ? _value.indexRecommendOrder
          : indexRecommendOrder // ignore: cast_nullable_to_non_nullable
              as int?,
      isNeedSwitchTradeTab: freezed == isNeedSwitchTradeTab
          ? _value.isNeedSwitchTradeTab
          : isNeedSwitchTradeTab // ignore: cast_nullable_to_non_nullable
              as bool?,
      isReverse: freezed == isReverse
          ? _value.isReverse
          : isReverse // ignore: cast_nullable_to_non_nullable
              as bool?,
      itemShowType: freezed == itemShowType
          ? _value.itemShowType
          : itemShowType // ignore: cast_nullable_to_non_nullable
              as int?,
      labelId: freezed == labelId
          ? _value.labelId
          : labelId // ignore: cast_nullable_to_non_nullable
              as String?,
      minPricePrecision: freezed == minPricePrecision
          ? _value.minPricePrecision
          : minPricePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      minTradeAmount: freezed == minTradeAmount
          ? _value.minTradeAmount
          : minTradeAmount // ignore: cast_nullable_to_non_nullable
              as String?,
      minTradeQuantity: freezed == minTradeQuantity
          ? _value.minTradeQuantity
          : minTradeQuantity // ignore: cast_nullable_to_non_nullable
              as String?,
      openStatus: freezed == openStatus
          ? _value.openStatus
          : openStatus // ignore: cast_nullable_to_non_nullable
              as bool?,
      orgId: freezed == orgId
          ? _value.orgId
          : orgId // ignore: cast_nullable_to_non_nullable
              as String?,
      priceDigit: freezed == priceDigit
          ? _value.priceDigit
          : priceDigit // ignore: cast_nullable_to_non_nullable
              as int?,
      quotePrecision: freezed == quotePrecision
          ? _value.quotePrecision
          : quotePrecision // ignore: cast_nullable_to_non_nullable
              as String?,
      quoteTokenId: freezed == quoteTokenId
          ? _value.quoteTokenId
          : quoteTokenId // ignore: cast_nullable_to_non_nullable
              as String?,
      quoteTokenName: freezed == quoteTokenName
          ? _value.quoteTokenName
          : quoteTokenName // ignore: cast_nullable_to_non_nullable
              as String?,
      select: freezed == select
          ? _value.select
          : select // ignore: cast_nullable_to_non_nullable
              as bool?,
      showStatus: freezed == showStatus
          ? _value.showStatus
          : showStatus // ignore: cast_nullable_to_non_nullable
              as bool?,
      symbolId: freezed == symbolId
          ? _value.symbolId
          : symbolId // ignore: cast_nullable_to_non_nullable
              as String?,
      symbolName: freezed == symbolName
          ? _value.symbolName
          : symbolName // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$BaseTokenSymbolsModelImpl
    with DiagnosticableTreeMixin
    implements _BaseTokenSymbolsModel {
  const _$BaseTokenSymbolsModelImpl(
      {required this.allowMargin,
      required this.allowPlan,
      required this.amountDigit,
      required this.baseDigit,
      required this.basePrecision,
      required this.baseTokenId,
      required this.baseTokenName,
      required this.buyMode,
      required this.canTrade,
      required this.category,
      required this.coinType,
      required this.customOrder,
      required this.digitMerge,
      required this.exchangeId,
      required this.favorite,
      required this.indexRecommendOrder,
      required this.isNeedSwitchTradeTab,
      required this.isReverse,
      required this.itemShowType,
      required this.labelId,
      required this.minPricePrecision,
      required this.minTradeAmount,
      required this.minTradeQuantity,
      required this.openStatus,
      required this.orgId,
      required this.priceDigit,
      required this.quotePrecision,
      required this.quoteTokenId,
      required this.quoteTokenName,
      required this.select,
      required this.showStatus,
      required this.symbolId,
      required this.symbolName});

  factory _$BaseTokenSymbolsModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$BaseTokenSymbolsModelImplFromJson(json);

  @override
  final bool? allowMargin;
  @override
  final bool? allowPlan;
  @override
  final int? amountDigit;
  @override
  final int? baseDigit;
  @override
  final String? basePrecision;
  @override
  final String? baseTokenId;
  @override
  final String? baseTokenName;
  @override
  final bool? buyMode;
  @override
  final bool? canTrade;
  @override
  final int? category;
  @override
  final int? coinType;
  @override
  final int? customOrder;
  @override
  final String? digitMerge;
  @override
  final String? exchangeId;
  @override
  final bool? favorite;
  @override
  final int? indexRecommendOrder;
  @override
  final bool? isNeedSwitchTradeTab;
  @override
  final bool? isReverse;
  @override
  final int? itemShowType;
  @override
  final String? labelId;
  @override
  final String? minPricePrecision;
  @override
  final String? minTradeAmount;
  @override
  final String? minTradeQuantity;
  @override
  final bool? openStatus;
  @override
  final String? orgId;
  @override
  final int? priceDigit;
  @override
  final String? quotePrecision;
  @override
  final String? quoteTokenId;
  @override
  final String? quoteTokenName;
  @override
  final bool? select;
  @override
  final bool? showStatus;
  @override
  final String? symbolId;
  @override
  final String? symbolName;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'BaseTokenSymbolsModel(allowMargin: $allowMargin, allowPlan: $allowPlan, amountDigit: $amountDigit, baseDigit: $baseDigit, basePrecision: $basePrecision, baseTokenId: $baseTokenId, baseTokenName: $baseTokenName, buyMode: $buyMode, canTrade: $canTrade, category: $category, coinType: $coinType, customOrder: $customOrder, digitMerge: $digitMerge, exchangeId: $exchangeId, favorite: $favorite, indexRecommendOrder: $indexRecommendOrder, isNeedSwitchTradeTab: $isNeedSwitchTradeTab, isReverse: $isReverse, itemShowType: $itemShowType, labelId: $labelId, minPricePrecision: $minPricePrecision, minTradeAmount: $minTradeAmount, minTradeQuantity: $minTradeQuantity, openStatus: $openStatus, orgId: $orgId, priceDigit: $priceDigit, quotePrecision: $quotePrecision, quoteTokenId: $quoteTokenId, quoteTokenName: $quoteTokenName, select: $select, showStatus: $showStatus, symbolId: $symbolId, symbolName: $symbolName)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'BaseTokenSymbolsModel'))
      ..add(DiagnosticsProperty('allowMargin', allowMargin))
      ..add(DiagnosticsProperty('allowPlan', allowPlan))
      ..add(DiagnosticsProperty('amountDigit', amountDigit))
      ..add(DiagnosticsProperty('baseDigit', baseDigit))
      ..add(DiagnosticsProperty('basePrecision', basePrecision))
      ..add(DiagnosticsProperty('baseTokenId', baseTokenId))
      ..add(DiagnosticsProperty('baseTokenName', baseTokenName))
      ..add(DiagnosticsProperty('buyMode', buyMode))
      ..add(DiagnosticsProperty('canTrade', canTrade))
      ..add(DiagnosticsProperty('category', category))
      ..add(DiagnosticsProperty('coinType', coinType))
      ..add(DiagnosticsProperty('customOrder', customOrder))
      ..add(DiagnosticsProperty('digitMerge', digitMerge))
      ..add(DiagnosticsProperty('exchangeId', exchangeId))
      ..add(DiagnosticsProperty('favorite', favorite))
      ..add(DiagnosticsProperty('indexRecommendOrder', indexRecommendOrder))
      ..add(DiagnosticsProperty('isNeedSwitchTradeTab', isNeedSwitchTradeTab))
      ..add(DiagnosticsProperty('isReverse', isReverse))
      ..add(DiagnosticsProperty('itemShowType', itemShowType))
      ..add(DiagnosticsProperty('labelId', labelId))
      ..add(DiagnosticsProperty('minPricePrecision', minPricePrecision))
      ..add(DiagnosticsProperty('minTradeAmount', minTradeAmount))
      ..add(DiagnosticsProperty('minTradeQuantity', minTradeQuantity))
      ..add(DiagnosticsProperty('openStatus', openStatus))
      ..add(DiagnosticsProperty('orgId', orgId))
      ..add(DiagnosticsProperty('priceDigit', priceDigit))
      ..add(DiagnosticsProperty('quotePrecision', quotePrecision))
      ..add(DiagnosticsProperty('quoteTokenId', quoteTokenId))
      ..add(DiagnosticsProperty('quoteTokenName', quoteTokenName))
      ..add(DiagnosticsProperty('select', select))
      ..add(DiagnosticsProperty('showStatus', showStatus))
      ..add(DiagnosticsProperty('symbolId', symbolId))
      ..add(DiagnosticsProperty('symbolName', symbolName));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BaseTokenSymbolsModelImpl &&
            (identical(other.allowMargin, allowMargin) ||
                other.allowMargin == allowMargin) &&
            (identical(other.allowPlan, allowPlan) ||
                other.allowPlan == allowPlan) &&
            (identical(other.amountDigit, amountDigit) ||
                other.amountDigit == amountDigit) &&
            (identical(other.baseDigit, baseDigit) ||
                other.baseDigit == baseDigit) &&
            (identical(other.basePrecision, basePrecision) ||
                other.basePrecision == basePrecision) &&
            (identical(other.baseTokenId, baseTokenId) ||
                other.baseTokenId == baseTokenId) &&
            (identical(other.baseTokenName, baseTokenName) ||
                other.baseTokenName == baseTokenName) &&
            (identical(other.buyMode, buyMode) || other.buyMode == buyMode) &&
            (identical(other.canTrade, canTrade) ||
                other.canTrade == canTrade) &&
            (identical(other.category, category) ||
                other.category == category) &&
            (identical(other.coinType, coinType) ||
                other.coinType == coinType) &&
            (identical(other.customOrder, customOrder) ||
                other.customOrder == customOrder) &&
            (identical(other.digitMerge, digitMerge) ||
                other.digitMerge == digitMerge) &&
            (identical(other.exchangeId, exchangeId) ||
                other.exchangeId == exchangeId) &&
            (identical(other.favorite, favorite) ||
                other.favorite == favorite) &&
            (identical(other.indexRecommendOrder, indexRecommendOrder) ||
                other.indexRecommendOrder == indexRecommendOrder) &&
            (identical(other.isNeedSwitchTradeTab, isNeedSwitchTradeTab) ||
                other.isNeedSwitchTradeTab == isNeedSwitchTradeTab) &&
            (identical(other.isReverse, isReverse) ||
                other.isReverse == isReverse) &&
            (identical(other.itemShowType, itemShowType) ||
                other.itemShowType == itemShowType) &&
            (identical(other.labelId, labelId) || other.labelId == labelId) &&
            (identical(other.minPricePrecision, minPricePrecision) ||
                other.minPricePrecision == minPricePrecision) &&
            (identical(other.minTradeAmount, minTradeAmount) ||
                other.minTradeAmount == minTradeAmount) &&
            (identical(other.minTradeQuantity, minTradeQuantity) ||
                other.minTradeQuantity == minTradeQuantity) &&
            (identical(other.openStatus, openStatus) ||
                other.openStatus == openStatus) &&
            (identical(other.orgId, orgId) || other.orgId == orgId) &&
            (identical(other.priceDigit, priceDigit) ||
                other.priceDigit == priceDigit) &&
            (identical(other.quotePrecision, quotePrecision) ||
                other.quotePrecision == quotePrecision) &&
            (identical(other.quoteTokenId, quoteTokenId) ||
                other.quoteTokenId == quoteTokenId) &&
            (identical(other.quoteTokenName, quoteTokenName) ||
                other.quoteTokenName == quoteTokenName) &&
            (identical(other.select, select) || other.select == select) &&
            (identical(other.showStatus, showStatus) ||
                other.showStatus == showStatus) &&
            (identical(other.symbolId, symbolId) ||
                other.symbolId == symbolId) &&
            (identical(other.symbolName, symbolName) ||
                other.symbolName == symbolName));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        allowMargin,
        allowPlan,
        amountDigit,
        baseDigit,
        basePrecision,
        baseTokenId,
        baseTokenName,
        buyMode,
        canTrade,
        category,
        coinType,
        customOrder,
        digitMerge,
        exchangeId,
        favorite,
        indexRecommendOrder,
        isNeedSwitchTradeTab,
        isReverse,
        itemShowType,
        labelId,
        minPricePrecision,
        minTradeAmount,
        minTradeQuantity,
        openStatus,
        orgId,
        priceDigit,
        quotePrecision,
        quoteTokenId,
        quoteTokenName,
        select,
        showStatus,
        symbolId,
        symbolName
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BaseTokenSymbolsModelImplCopyWith<_$BaseTokenSymbolsModelImpl>
      get copyWith => __$$BaseTokenSymbolsModelImplCopyWithImpl<
          _$BaseTokenSymbolsModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$BaseTokenSymbolsModelImplToJson(
      this,
    );
  }
}

abstract class _BaseTokenSymbolsModel implements BaseTokenSymbolsModel {
  const factory _BaseTokenSymbolsModel(
      {required final bool? allowMargin,
      required final bool? allowPlan,
      required final int? amountDigit,
      required final int? baseDigit,
      required final String? basePrecision,
      required final String? baseTokenId,
      required final String? baseTokenName,
      required final bool? buyMode,
      required final bool? canTrade,
      required final int? category,
      required final int? coinType,
      required final int? customOrder,
      required final String? digitMerge,
      required final String? exchangeId,
      required final bool? favorite,
      required final int? indexRecommendOrder,
      required final bool? isNeedSwitchTradeTab,
      required final bool? isReverse,
      required final int? itemShowType,
      required final String? labelId,
      required final String? minPricePrecision,
      required final String? minTradeAmount,
      required final String? minTradeQuantity,
      required final bool? openStatus,
      required final String? orgId,
      required final int? priceDigit,
      required final String? quotePrecision,
      required final String? quoteTokenId,
      required final String? quoteTokenName,
      required final bool? select,
      required final bool? showStatus,
      required final String? symbolId,
      required final String? symbolName}) = _$BaseTokenSymbolsModelImpl;

  factory _BaseTokenSymbolsModel.fromJson(Map<String, dynamic> json) =
      _$BaseTokenSymbolsModelImpl.fromJson;

  @override
  bool? get allowMargin;
  @override
  bool? get allowPlan;
  @override
  int? get amountDigit;
  @override
  int? get baseDigit;
  @override
  String? get basePrecision;
  @override
  String? get baseTokenId;
  @override
  String? get baseTokenName;
  @override
  bool? get buyMode;
  @override
  bool? get canTrade;
  @override
  int? get category;
  @override
  int? get coinType;
  @override
  int? get customOrder;
  @override
  String? get digitMerge;
  @override
  String? get exchangeId;
  @override
  bool? get favorite;
  @override
  int? get indexRecommendOrder;
  @override
  bool? get isNeedSwitchTradeTab;
  @override
  bool? get isReverse;
  @override
  int? get itemShowType;
  @override
  String? get labelId;
  @override
  String? get minPricePrecision;
  @override
  String? get minTradeAmount;
  @override
  String? get minTradeQuantity;
  @override
  bool? get openStatus;
  @override
  String? get orgId;
  @override
  int? get priceDigit;
  @override
  String? get quotePrecision;
  @override
  String? get quoteTokenId;
  @override
  String? get quoteTokenName;
  @override
  bool? get select;
  @override
  bool? get showStatus;
  @override
  String? get symbolId;
  @override
  String? get symbolName;
  @override
  @JsonKey(ignore: true)
  _$$BaseTokenSymbolsModelImplCopyWith<_$BaseTokenSymbolsModelImpl>
      get copyWith => throw _privateConstructorUsedError;
}

ChainTypeModel _$ChainTypeModelFromJson(Map<String, dynamic> json) {
  return _ChainTypeModel.fromJson(json);
}

/// @nodoc
mixin _$ChainTypeModel {
  String? get chainType => throw _privateConstructorUsedError;
  bool? get allowDeposit => throw _privateConstructorUsedError;
  bool? get allowWithdraw => throw _privateConstructorUsedError;
  bool? get select => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ChainTypeModelCopyWith<ChainTypeModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ChainTypeModelCopyWith<$Res> {
  factory $ChainTypeModelCopyWith(
          ChainTypeModel value, $Res Function(ChainTypeModel) then) =
      _$ChainTypeModelCopyWithImpl<$Res, ChainTypeModel>;
  @useResult
  $Res call(
      {String? chainType,
      bool? allowDeposit,
      bool? allowWithdraw,
      bool? select});
}

/// @nodoc
class _$ChainTypeModelCopyWithImpl<$Res, $Val extends ChainTypeModel>
    implements $ChainTypeModelCopyWith<$Res> {
  _$ChainTypeModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chainType = freezed,
    Object? allowDeposit = freezed,
    Object? allowWithdraw = freezed,
    Object? select = freezed,
  }) {
    return _then(_value.copyWith(
      chainType: freezed == chainType
          ? _value.chainType
          : chainType // ignore: cast_nullable_to_non_nullable
              as String?,
      allowDeposit: freezed == allowDeposit
          ? _value.allowDeposit
          : allowDeposit // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowWithdraw: freezed == allowWithdraw
          ? _value.allowWithdraw
          : allowWithdraw // ignore: cast_nullable_to_non_nullable
              as bool?,
      select: freezed == select
          ? _value.select
          : select // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ChainTypeModelImplCopyWith<$Res>
    implements $ChainTypeModelCopyWith<$Res> {
  factory _$$ChainTypeModelImplCopyWith(_$ChainTypeModelImpl value,
          $Res Function(_$ChainTypeModelImpl) then) =
      __$$ChainTypeModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? chainType,
      bool? allowDeposit,
      bool? allowWithdraw,
      bool? select});
}

/// @nodoc
class __$$ChainTypeModelImplCopyWithImpl<$Res>
    extends _$ChainTypeModelCopyWithImpl<$Res, _$ChainTypeModelImpl>
    implements _$$ChainTypeModelImplCopyWith<$Res> {
  __$$ChainTypeModelImplCopyWithImpl(
      _$ChainTypeModelImpl _value, $Res Function(_$ChainTypeModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chainType = freezed,
    Object? allowDeposit = freezed,
    Object? allowWithdraw = freezed,
    Object? select = freezed,
  }) {
    return _then(_$ChainTypeModelImpl(
      chainType: freezed == chainType
          ? _value.chainType
          : chainType // ignore: cast_nullable_to_non_nullable
              as String?,
      allowDeposit: freezed == allowDeposit
          ? _value.allowDeposit
          : allowDeposit // ignore: cast_nullable_to_non_nullable
              as bool?,
      allowWithdraw: freezed == allowWithdraw
          ? _value.allowWithdraw
          : allowWithdraw // ignore: cast_nullable_to_non_nullable
              as bool?,
      select: freezed == select
          ? _value.select
          : select // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ChainTypeModelImpl
    with DiagnosticableTreeMixin
    implements _ChainTypeModel {
  const _$ChainTypeModelImpl(
      {required this.chainType,
      required this.allowDeposit,
      required this.allowWithdraw,
      required this.select});

  factory _$ChainTypeModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$ChainTypeModelImplFromJson(json);

  @override
  final String? chainType;
  @override
  final bool? allowDeposit;
  @override
  final bool? allowWithdraw;
  @override
  final bool? select;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ChainTypeModel(chainType: $chainType, allowDeposit: $allowDeposit, allowWithdraw: $allowWithdraw, select: $select)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ChainTypeModel'))
      ..add(DiagnosticsProperty('chainType', chainType))
      ..add(DiagnosticsProperty('allowDeposit', allowDeposit))
      ..add(DiagnosticsProperty('allowWithdraw', allowWithdraw))
      ..add(DiagnosticsProperty('select', select));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChainTypeModelImpl &&
            (identical(other.chainType, chainType) ||
                other.chainType == chainType) &&
            (identical(other.allowDeposit, allowDeposit) ||
                other.allowDeposit == allowDeposit) &&
            (identical(other.allowWithdraw, allowWithdraw) ||
                other.allowWithdraw == allowWithdraw) &&
            (identical(other.select, select) || other.select == select));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, chainType, allowDeposit, allowWithdraw, select);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ChainTypeModelImplCopyWith<_$ChainTypeModelImpl> get copyWith =>
      __$$ChainTypeModelImplCopyWithImpl<_$ChainTypeModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ChainTypeModelImplToJson(
      this,
    );
  }
}

abstract class _ChainTypeModel implements ChainTypeModel {
  const factory _ChainTypeModel(
      {required final String? chainType,
      required final bool? allowDeposit,
      required final bool? allowWithdraw,
      required final bool? select}) = _$ChainTypeModelImpl;

  factory _ChainTypeModel.fromJson(Map<String, dynamic> json) =
      _$ChainTypeModelImpl.fromJson;

  @override
  String? get chainType;
  @override
  bool? get allowDeposit;
  @override
  bool? get allowWithdraw;
  @override
  bool? get select;
  @override
  @JsonKey(ignore: true)
  _$$ChainTypeModelImplCopyWith<_$ChainTypeModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
