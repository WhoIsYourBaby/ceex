// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'kline_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

KlineModel _$KlineModelFromJson(Map<String, dynamic> json) {
  return _KlineModel.fromJson(json);
}

/// @nodoc
mixin _$KlineModel {
  /// time
  num? get t => throw _privateConstructorUsedError;

  /// symbol
  String? get s => throw _privateConstructorUsedError;

  /// close price
  String? get c => throw _privateConstructorUsedError;

  /// high price
  String? get h => throw _privateConstructorUsedError;

  /// low price
  String? get l => throw _privateConstructorUsedError;

  /// open price
  String? get o => throw _privateConstructorUsedError;

  /// volume
  String? get v => throw _privateConstructorUsedError;

  /// quote * volume
  String? get qv => throw _privateConstructorUsedError;

  /// margin 涨跌幅
  String? get m => throw _privateConstructorUsedError;

  /// exchangeId
  int? get e => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $KlineModelCopyWith<KlineModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KlineModelCopyWith<$Res> {
  factory $KlineModelCopyWith(
          KlineModel value, $Res Function(KlineModel) then) =
      _$KlineModelCopyWithImpl<$Res, KlineModel>;
  @useResult
  $Res call(
      {num? t,
      String? s,
      String? c,
      String? h,
      String? l,
      String? o,
      String? v,
      String? qv,
      String? m,
      int? e});
}

/// @nodoc
class _$KlineModelCopyWithImpl<$Res, $Val extends KlineModel>
    implements $KlineModelCopyWith<$Res> {
  _$KlineModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t = freezed,
    Object? s = freezed,
    Object? c = freezed,
    Object? h = freezed,
    Object? l = freezed,
    Object? o = freezed,
    Object? v = freezed,
    Object? qv = freezed,
    Object? m = freezed,
    Object? e = freezed,
  }) {
    return _then(_value.copyWith(
      t: freezed == t
          ? _value.t
          : t // ignore: cast_nullable_to_non_nullable
              as num?,
      s: freezed == s
          ? _value.s
          : s // ignore: cast_nullable_to_non_nullable
              as String?,
      c: freezed == c
          ? _value.c
          : c // ignore: cast_nullable_to_non_nullable
              as String?,
      h: freezed == h
          ? _value.h
          : h // ignore: cast_nullable_to_non_nullable
              as String?,
      l: freezed == l
          ? _value.l
          : l // ignore: cast_nullable_to_non_nullable
              as String?,
      o: freezed == o
          ? _value.o
          : o // ignore: cast_nullable_to_non_nullable
              as String?,
      v: freezed == v
          ? _value.v
          : v // ignore: cast_nullable_to_non_nullable
              as String?,
      qv: freezed == qv
          ? _value.qv
          : qv // ignore: cast_nullable_to_non_nullable
              as String?,
      m: freezed == m
          ? _value.m
          : m // ignore: cast_nullable_to_non_nullable
              as String?,
      e: freezed == e
          ? _value.e
          : e // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$KlineModelImplCopyWith<$Res>
    implements $KlineModelCopyWith<$Res> {
  factory _$$KlineModelImplCopyWith(
          _$KlineModelImpl value, $Res Function(_$KlineModelImpl) then) =
      __$$KlineModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {num? t,
      String? s,
      String? c,
      String? h,
      String? l,
      String? o,
      String? v,
      String? qv,
      String? m,
      int? e});
}

/// @nodoc
class __$$KlineModelImplCopyWithImpl<$Res>
    extends _$KlineModelCopyWithImpl<$Res, _$KlineModelImpl>
    implements _$$KlineModelImplCopyWith<$Res> {
  __$$KlineModelImplCopyWithImpl(
      _$KlineModelImpl _value, $Res Function(_$KlineModelImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? t = freezed,
    Object? s = freezed,
    Object? c = freezed,
    Object? h = freezed,
    Object? l = freezed,
    Object? o = freezed,
    Object? v = freezed,
    Object? qv = freezed,
    Object? m = freezed,
    Object? e = freezed,
  }) {
    return _then(_$KlineModelImpl(
      t: freezed == t
          ? _value.t
          : t // ignore: cast_nullable_to_non_nullable
              as num?,
      s: freezed == s
          ? _value.s
          : s // ignore: cast_nullable_to_non_nullable
              as String?,
      c: freezed == c
          ? _value.c
          : c // ignore: cast_nullable_to_non_nullable
              as String?,
      h: freezed == h
          ? _value.h
          : h // ignore: cast_nullable_to_non_nullable
              as String?,
      l: freezed == l
          ? _value.l
          : l // ignore: cast_nullable_to_non_nullable
              as String?,
      o: freezed == o
          ? _value.o
          : o // ignore: cast_nullable_to_non_nullable
              as String?,
      v: freezed == v
          ? _value.v
          : v // ignore: cast_nullable_to_non_nullable
              as String?,
      qv: freezed == qv
          ? _value.qv
          : qv // ignore: cast_nullable_to_non_nullable
              as String?,
      m: freezed == m
          ? _value.m
          : m // ignore: cast_nullable_to_non_nullable
              as String?,
      e: freezed == e
          ? _value.e
          : e // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$KlineModelImpl extends _KlineModel with DiagnosticableTreeMixin {
  const _$KlineModelImpl(
      {this.t,
      this.s,
      this.c,
      this.h,
      this.l,
      this.o,
      this.v,
      this.qv,
      this.m,
      this.e})
      : super._();

  factory _$KlineModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$KlineModelImplFromJson(json);

  /// time
  @override
  final num? t;

  /// symbol
  @override
  final String? s;

  /// close price
  @override
  final String? c;

  /// high price
  @override
  final String? h;

  /// low price
  @override
  final String? l;

  /// open price
  @override
  final String? o;

  /// volume
  @override
  final String? v;

  /// quote * volume
  @override
  final String? qv;

  /// margin 涨跌幅
  @override
  final String? m;

  /// exchangeId
  @override
  final int? e;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'KlineModel(t: $t, s: $s, c: $c, h: $h, l: $l, o: $o, v: $v, qv: $qv, m: $m, e: $e)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'KlineModel'))
      ..add(DiagnosticsProperty('t', t))
      ..add(DiagnosticsProperty('s', s))
      ..add(DiagnosticsProperty('c', c))
      ..add(DiagnosticsProperty('h', h))
      ..add(DiagnosticsProperty('l', l))
      ..add(DiagnosticsProperty('o', o))
      ..add(DiagnosticsProperty('v', v))
      ..add(DiagnosticsProperty('qv', qv))
      ..add(DiagnosticsProperty('m', m))
      ..add(DiagnosticsProperty('e', e));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KlineModelImpl &&
            (identical(other.t, t) || other.t == t) &&
            (identical(other.s, s) || other.s == s) &&
            (identical(other.c, c) || other.c == c) &&
            (identical(other.h, h) || other.h == h) &&
            (identical(other.l, l) || other.l == l) &&
            (identical(other.o, o) || other.o == o) &&
            (identical(other.v, v) || other.v == v) &&
            (identical(other.qv, qv) || other.qv == qv) &&
            (identical(other.m, m) || other.m == m) &&
            (identical(other.e, e) || other.e == e));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, t, s, c, h, l, o, v, qv, m, e);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KlineModelImplCopyWith<_$KlineModelImpl> get copyWith =>
      __$$KlineModelImplCopyWithImpl<_$KlineModelImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$KlineModelImplToJson(
      this,
    );
  }
}

abstract class _KlineModel extends KlineModel {
  const factory _KlineModel(
      {final num? t,
      final String? s,
      final String? c,
      final String? h,
      final String? l,
      final String? o,
      final String? v,
      final String? qv,
      final String? m,
      final int? e}) = _$KlineModelImpl;
  const _KlineModel._() : super._();

  factory _KlineModel.fromJson(Map<String, dynamic> json) =
      _$KlineModelImpl.fromJson;

  @override

  /// time
  num? get t;
  @override

  /// symbol
  String? get s;
  @override

  /// close price
  String? get c;
  @override

  /// high price
  String? get h;
  @override

  /// low price
  String? get l;
  @override

  /// open price
  String? get o;
  @override

  /// volume
  String? get v;
  @override

  /// quote * volume
  String? get qv;
  @override

  /// margin 涨跌幅
  String? get m;
  @override

  /// exchangeId
  int? get e;
  @override
  @JsonKey(ignore: true)
  _$$KlineModelImplCopyWith<_$KlineModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

MultiKlineQuery _$MultiKlineQueryFromJson(Map<String, dynamic> json) {
  return _MultiKlineQuery.fromJson(json);
}

/// @nodoc
mixin _$MultiKlineQuery {
  String? get symbol => throw _privateConstructorUsedError;
  num? get exchangeId => throw _privateConstructorUsedError;
  String? get interval => throw _privateConstructorUsedError;
  num? get limit => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MultiKlineQueryCopyWith<MultiKlineQuery> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MultiKlineQueryCopyWith<$Res> {
  factory $MultiKlineQueryCopyWith(
          MultiKlineQuery value, $Res Function(MultiKlineQuery) then) =
      _$MultiKlineQueryCopyWithImpl<$Res, MultiKlineQuery>;
  @useResult
  $Res call({String? symbol, num? exchangeId, String? interval, num? limit});
}

/// @nodoc
class _$MultiKlineQueryCopyWithImpl<$Res, $Val extends MultiKlineQuery>
    implements $MultiKlineQueryCopyWith<$Res> {
  _$MultiKlineQueryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? symbol = freezed,
    Object? exchangeId = freezed,
    Object? interval = freezed,
    Object? limit = freezed,
  }) {
    return _then(_value.copyWith(
      symbol: freezed == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String?,
      exchangeId: freezed == exchangeId
          ? _value.exchangeId
          : exchangeId // ignore: cast_nullable_to_non_nullable
              as num?,
      interval: freezed == interval
          ? _value.interval
          : interval // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as num?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MultiKlineQueryImplCopyWith<$Res>
    implements $MultiKlineQueryCopyWith<$Res> {
  factory _$$MultiKlineQueryImplCopyWith(_$MultiKlineQueryImpl value,
          $Res Function(_$MultiKlineQueryImpl) then) =
      __$$MultiKlineQueryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? symbol, num? exchangeId, String? interval, num? limit});
}

/// @nodoc
class __$$MultiKlineQueryImplCopyWithImpl<$Res>
    extends _$MultiKlineQueryCopyWithImpl<$Res, _$MultiKlineQueryImpl>
    implements _$$MultiKlineQueryImplCopyWith<$Res> {
  __$$MultiKlineQueryImplCopyWithImpl(
      _$MultiKlineQueryImpl _value, $Res Function(_$MultiKlineQueryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? symbol = freezed,
    Object? exchangeId = freezed,
    Object? interval = freezed,
    Object? limit = freezed,
  }) {
    return _then(_$MultiKlineQueryImpl(
      symbol: freezed == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String?,
      exchangeId: freezed == exchangeId
          ? _value.exchangeId
          : exchangeId // ignore: cast_nullable_to_non_nullable
              as num?,
      interval: freezed == interval
          ? _value.interval
          : interval // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as num?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MultiKlineQueryImpl
    with DiagnosticableTreeMixin
    implements _MultiKlineQuery {
  const _$MultiKlineQueryImpl(
      {this.symbol, this.exchangeId, this.interval, this.limit});

  factory _$MultiKlineQueryImpl.fromJson(Map<String, dynamic> json) =>
      _$$MultiKlineQueryImplFromJson(json);

  @override
  final String? symbol;
  @override
  final num? exchangeId;
  @override
  final String? interval;
  @override
  final num? limit;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MultiKlineQuery(symbol: $symbol, exchangeId: $exchangeId, interval: $interval, limit: $limit)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'MultiKlineQuery'))
      ..add(DiagnosticsProperty('symbol', symbol))
      ..add(DiagnosticsProperty('exchangeId', exchangeId))
      ..add(DiagnosticsProperty('interval', interval))
      ..add(DiagnosticsProperty('limit', limit));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MultiKlineQueryImpl &&
            (identical(other.symbol, symbol) || other.symbol == symbol) &&
            (identical(other.exchangeId, exchangeId) ||
                other.exchangeId == exchangeId) &&
            (identical(other.interval, interval) ||
                other.interval == interval) &&
            (identical(other.limit, limit) || other.limit == limit));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, symbol, exchangeId, interval, limit);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MultiKlineQueryImplCopyWith<_$MultiKlineQueryImpl> get copyWith =>
      __$$MultiKlineQueryImplCopyWithImpl<_$MultiKlineQueryImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$MultiKlineQueryImplToJson(
      this,
    );
  }
}

abstract class _MultiKlineQuery implements MultiKlineQuery {
  const factory _MultiKlineQuery(
      {final String? symbol,
      final num? exchangeId,
      final String? interval,
      final num? limit}) = _$MultiKlineQueryImpl;

  factory _MultiKlineQuery.fromJson(Map<String, dynamic> json) =
      _$MultiKlineQueryImpl.fromJson;

  @override
  String? get symbol;
  @override
  num? get exchangeId;
  @override
  String? get interval;
  @override
  num? get limit;
  @override
  @JsonKey(ignore: true)
  _$$MultiKlineQueryImplCopyWith<_$MultiKlineQueryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

KlineQuery _$KlineQueryFromJson(Map<String, dynamic> json) {
  return _KlineQuery.fromJson(json);
}

/// @nodoc
mixin _$KlineQuery {
  String? get symbol => throw _privateConstructorUsedError;
  String? get interval => throw _privateConstructorUsedError;
  num? get limit => throw _privateConstructorUsedError;
  String? get realtimeInterval => throw _privateConstructorUsedError; //  时间戳
  String? get to => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $KlineQueryCopyWith<KlineQuery> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KlineQueryCopyWith<$Res> {
  factory $KlineQueryCopyWith(
          KlineQuery value, $Res Function(KlineQuery) then) =
      _$KlineQueryCopyWithImpl<$Res, KlineQuery>;
  @useResult
  $Res call(
      {String? symbol,
      String? interval,
      num? limit,
      String? realtimeInterval,
      String? to});
}

/// @nodoc
class _$KlineQueryCopyWithImpl<$Res, $Val extends KlineQuery>
    implements $KlineQueryCopyWith<$Res> {
  _$KlineQueryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? symbol = freezed,
    Object? interval = freezed,
    Object? limit = freezed,
    Object? realtimeInterval = freezed,
    Object? to = freezed,
  }) {
    return _then(_value.copyWith(
      symbol: freezed == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String?,
      interval: freezed == interval
          ? _value.interval
          : interval // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as num?,
      realtimeInterval: freezed == realtimeInterval
          ? _value.realtimeInterval
          : realtimeInterval // ignore: cast_nullable_to_non_nullable
              as String?,
      to: freezed == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$KlineQueryImplCopyWith<$Res>
    implements $KlineQueryCopyWith<$Res> {
  factory _$$KlineQueryImplCopyWith(
          _$KlineQueryImpl value, $Res Function(_$KlineQueryImpl) then) =
      __$$KlineQueryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? symbol,
      String? interval,
      num? limit,
      String? realtimeInterval,
      String? to});
}

/// @nodoc
class __$$KlineQueryImplCopyWithImpl<$Res>
    extends _$KlineQueryCopyWithImpl<$Res, _$KlineQueryImpl>
    implements _$$KlineQueryImplCopyWith<$Res> {
  __$$KlineQueryImplCopyWithImpl(
      _$KlineQueryImpl _value, $Res Function(_$KlineQueryImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? symbol = freezed,
    Object? interval = freezed,
    Object? limit = freezed,
    Object? realtimeInterval = freezed,
    Object? to = freezed,
  }) {
    return _then(_$KlineQueryImpl(
      symbol: freezed == symbol
          ? _value.symbol
          : symbol // ignore: cast_nullable_to_non_nullable
              as String?,
      interval: freezed == interval
          ? _value.interval
          : interval // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: freezed == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as num?,
      realtimeInterval: freezed == realtimeInterval
          ? _value.realtimeInterval
          : realtimeInterval // ignore: cast_nullable_to_non_nullable
              as String?,
      to: freezed == to
          ? _value.to
          : to // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$KlineQueryImpl with DiagnosticableTreeMixin implements _KlineQuery {
  const _$KlineQueryImpl(
      {this.symbol,
      this.interval,
      this.limit = 300,
      this.realtimeInterval = "24h",
      this.to});

  factory _$KlineQueryImpl.fromJson(Map<String, dynamic> json) =>
      _$$KlineQueryImplFromJson(json);

  @override
  final String? symbol;
  @override
  final String? interval;
  @override
  @JsonKey()
  final num? limit;
  @override
  @JsonKey()
  final String? realtimeInterval;
//  时间戳
  @override
  final String? to;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'KlineQuery(symbol: $symbol, interval: $interval, limit: $limit, realtimeInterval: $realtimeInterval, to: $to)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'KlineQuery'))
      ..add(DiagnosticsProperty('symbol', symbol))
      ..add(DiagnosticsProperty('interval', interval))
      ..add(DiagnosticsProperty('limit', limit))
      ..add(DiagnosticsProperty('realtimeInterval', realtimeInterval))
      ..add(DiagnosticsProperty('to', to));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KlineQueryImpl &&
            (identical(other.symbol, symbol) || other.symbol == symbol) &&
            (identical(other.interval, interval) ||
                other.interval == interval) &&
            (identical(other.limit, limit) || other.limit == limit) &&
            (identical(other.realtimeInterval, realtimeInterval) ||
                other.realtimeInterval == realtimeInterval) &&
            (identical(other.to, to) || other.to == to));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode =>
      Object.hash(runtimeType, symbol, interval, limit, realtimeInterval, to);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$KlineQueryImplCopyWith<_$KlineQueryImpl> get copyWith =>
      __$$KlineQueryImplCopyWithImpl<_$KlineQueryImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$KlineQueryImplToJson(
      this,
    );
  }
}

abstract class _KlineQuery implements KlineQuery {
  const factory _KlineQuery(
      {final String? symbol,
      final String? interval,
      final num? limit,
      final String? realtimeInterval,
      final String? to}) = _$KlineQueryImpl;

  factory _KlineQuery.fromJson(Map<String, dynamic> json) =
      _$KlineQueryImpl.fromJson;

  @override
  String? get symbol;
  @override
  String? get interval;
  @override
  num? get limit;
  @override
  String? get realtimeInterval;
  @override //  时间戳
  String? get to;
  @override
  @JsonKey(ignore: true)
  _$$KlineQueryImplCopyWith<_$KlineQueryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
