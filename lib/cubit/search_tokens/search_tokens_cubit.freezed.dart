// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'search_tokens_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$SearchTokensState {
  Map<String, List<TokenModel>>? get tokensMap =>
      throw _privateConstructorUsedError;
  List<String>? get letterList => throw _privateConstructorUsedError;
  bool? get showSearchResult => throw _privateConstructorUsedError;
  List<TokenModel>? get searchResultList => throw _privateConstructorUsedError;
  TokenModel? get hot1 => throw _privateConstructorUsedError;
  TokenModel? get hot2 => throw _privateConstructorUsedError;
  TokenModel? get hot3 => throw _privateConstructorUsedError;
  TokenModel? get hot4 => throw _privateConstructorUsedError;
  List<TokenModel>? get hotList => throw _privateConstructorUsedError;
  List<TokenModel>? get tokenList => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            Map<String, List<TokenModel>>? tokensMap,
            List<String>? letterList,
            bool? showSearchResult,
            List<TokenModel>? searchResultList,
            TokenModel? hot1,
            TokenModel? hot2,
            TokenModel? hot3,
            TokenModel? hot4,
            List<TokenModel>? hotList,
            List<TokenModel>? tokenList)
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            Map<String, List<TokenModel>>? tokensMap,
            List<String>? letterList,
            bool? showSearchResult,
            List<TokenModel>? searchResultList,
            TokenModel? hot1,
            TokenModel? hot2,
            TokenModel? hot3,
            TokenModel? hot4,
            List<TokenModel>? hotList,
            List<TokenModel>? tokenList)?
        initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            Map<String, List<TokenModel>>? tokensMap,
            List<String>? letterList,
            bool? showSearchResult,
            List<TokenModel>? searchResultList,
            TokenModel? hot1,
            TokenModel? hot2,
            TokenModel? hot3,
            TokenModel? hot4,
            List<TokenModel>? hotList,
            List<TokenModel>? tokenList)?
        initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SearchTokensStateCopyWith<SearchTokensState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SearchTokensStateCopyWith<$Res> {
  factory $SearchTokensStateCopyWith(
          SearchTokensState value, $Res Function(SearchTokensState) then) =
      _$SearchTokensStateCopyWithImpl<$Res, SearchTokensState>;
  @useResult
  $Res call(
      {Map<String, List<TokenModel>>? tokensMap,
      List<String>? letterList,
      bool? showSearchResult,
      List<TokenModel>? searchResultList,
      TokenModel? hot1,
      TokenModel? hot2,
      TokenModel? hot3,
      TokenModel? hot4,
      List<TokenModel>? hotList,
      List<TokenModel>? tokenList});

  $TokenModelCopyWith<$Res>? get hot1;
  $TokenModelCopyWith<$Res>? get hot2;
  $TokenModelCopyWith<$Res>? get hot3;
  $TokenModelCopyWith<$Res>? get hot4;
}

/// @nodoc
class _$SearchTokensStateCopyWithImpl<$Res, $Val extends SearchTokensState>
    implements $SearchTokensStateCopyWith<$Res> {
  _$SearchTokensStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tokensMap = freezed,
    Object? letterList = freezed,
    Object? showSearchResult = freezed,
    Object? searchResultList = freezed,
    Object? hot1 = freezed,
    Object? hot2 = freezed,
    Object? hot3 = freezed,
    Object? hot4 = freezed,
    Object? hotList = freezed,
    Object? tokenList = freezed,
  }) {
    return _then(_value.copyWith(
      tokensMap: freezed == tokensMap
          ? _value.tokensMap
          : tokensMap // ignore: cast_nullable_to_non_nullable
              as Map<String, List<TokenModel>>?,
      letterList: freezed == letterList
          ? _value.letterList
          : letterList // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      showSearchResult: freezed == showSearchResult
          ? _value.showSearchResult
          : showSearchResult // ignore: cast_nullable_to_non_nullable
              as bool?,
      searchResultList: freezed == searchResultList
          ? _value.searchResultList
          : searchResultList // ignore: cast_nullable_to_non_nullable
              as List<TokenModel>?,
      hot1: freezed == hot1
          ? _value.hot1
          : hot1 // ignore: cast_nullable_to_non_nullable
              as TokenModel?,
      hot2: freezed == hot2
          ? _value.hot2
          : hot2 // ignore: cast_nullable_to_non_nullable
              as TokenModel?,
      hot3: freezed == hot3
          ? _value.hot3
          : hot3 // ignore: cast_nullable_to_non_nullable
              as TokenModel?,
      hot4: freezed == hot4
          ? _value.hot4
          : hot4 // ignore: cast_nullable_to_non_nullable
              as TokenModel?,
      hotList: freezed == hotList
          ? _value.hotList
          : hotList // ignore: cast_nullable_to_non_nullable
              as List<TokenModel>?,
      tokenList: freezed == tokenList
          ? _value.tokenList
          : tokenList // ignore: cast_nullable_to_non_nullable
              as List<TokenModel>?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $TokenModelCopyWith<$Res>? get hot1 {
    if (_value.hot1 == null) {
      return null;
    }

    return $TokenModelCopyWith<$Res>(_value.hot1!, (value) {
      return _then(_value.copyWith(hot1: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TokenModelCopyWith<$Res>? get hot2 {
    if (_value.hot2 == null) {
      return null;
    }

    return $TokenModelCopyWith<$Res>(_value.hot2!, (value) {
      return _then(_value.copyWith(hot2: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TokenModelCopyWith<$Res>? get hot3 {
    if (_value.hot3 == null) {
      return null;
    }

    return $TokenModelCopyWith<$Res>(_value.hot3!, (value) {
      return _then(_value.copyWith(hot3: value) as $Val);
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $TokenModelCopyWith<$Res>? get hot4 {
    if (_value.hot4 == null) {
      return null;
    }

    return $TokenModelCopyWith<$Res>(_value.hot4!, (value) {
      return _then(_value.copyWith(hot4: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res>
    implements $SearchTokensStateCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Map<String, List<TokenModel>>? tokensMap,
      List<String>? letterList,
      bool? showSearchResult,
      List<TokenModel>? searchResultList,
      TokenModel? hot1,
      TokenModel? hot2,
      TokenModel? hot3,
      TokenModel? hot4,
      List<TokenModel>? hotList,
      List<TokenModel>? tokenList});

  @override
  $TokenModelCopyWith<$Res>? get hot1;
  @override
  $TokenModelCopyWith<$Res>? get hot2;
  @override
  $TokenModelCopyWith<$Res>? get hot3;
  @override
  $TokenModelCopyWith<$Res>? get hot4;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$SearchTokensStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? tokensMap = freezed,
    Object? letterList = freezed,
    Object? showSearchResult = freezed,
    Object? searchResultList = freezed,
    Object? hot1 = freezed,
    Object? hot2 = freezed,
    Object? hot3 = freezed,
    Object? hot4 = freezed,
    Object? hotList = freezed,
    Object? tokenList = freezed,
  }) {
    return _then(_$InitialImpl(
      tokensMap: freezed == tokensMap
          ? _value._tokensMap
          : tokensMap // ignore: cast_nullable_to_non_nullable
              as Map<String, List<TokenModel>>?,
      letterList: freezed == letterList
          ? _value._letterList
          : letterList // ignore: cast_nullable_to_non_nullable
              as List<String>?,
      showSearchResult: freezed == showSearchResult
          ? _value.showSearchResult
          : showSearchResult // ignore: cast_nullable_to_non_nullable
              as bool?,
      searchResultList: freezed == searchResultList
          ? _value._searchResultList
          : searchResultList // ignore: cast_nullable_to_non_nullable
              as List<TokenModel>?,
      hot1: freezed == hot1
          ? _value.hot1
          : hot1 // ignore: cast_nullable_to_non_nullable
              as TokenModel?,
      hot2: freezed == hot2
          ? _value.hot2
          : hot2 // ignore: cast_nullable_to_non_nullable
              as TokenModel?,
      hot3: freezed == hot3
          ? _value.hot3
          : hot3 // ignore: cast_nullable_to_non_nullable
              as TokenModel?,
      hot4: freezed == hot4
          ? _value.hot4
          : hot4 // ignore: cast_nullable_to_non_nullable
              as TokenModel?,
      hotList: freezed == hotList
          ? _value._hotList
          : hotList // ignore: cast_nullable_to_non_nullable
              as List<TokenModel>?,
      tokenList: freezed == tokenList
          ? _value._tokenList
          : tokenList // ignore: cast_nullable_to_non_nullable
              as List<TokenModel>?,
    ));
  }
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl(
      {final Map<String, List<TokenModel>>? tokensMap,
      final List<String>? letterList,
      this.showSearchResult,
      final List<TokenModel>? searchResultList,
      this.hot1,
      this.hot2,
      this.hot3,
      this.hot4,
      final List<TokenModel>? hotList,
      final List<TokenModel>? tokenList})
      : _tokensMap = tokensMap,
        _letterList = letterList,
        _searchResultList = searchResultList,
        _hotList = hotList,
        _tokenList = tokenList;

  final Map<String, List<TokenModel>>? _tokensMap;
  @override
  Map<String, List<TokenModel>>? get tokensMap {
    final value = _tokensMap;
    if (value == null) return null;
    if (_tokensMap is EqualUnmodifiableMapView) return _tokensMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  final List<String>? _letterList;
  @override
  List<String>? get letterList {
    final value = _letterList;
    if (value == null) return null;
    if (_letterList is EqualUnmodifiableListView) return _letterList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final bool? showSearchResult;
  final List<TokenModel>? _searchResultList;
  @override
  List<TokenModel>? get searchResultList {
    final value = _searchResultList;
    if (value == null) return null;
    if (_searchResultList is EqualUnmodifiableListView)
      return _searchResultList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final TokenModel? hot1;
  @override
  final TokenModel? hot2;
  @override
  final TokenModel? hot3;
  @override
  final TokenModel? hot4;
  final List<TokenModel>? _hotList;
  @override
  List<TokenModel>? get hotList {
    final value = _hotList;
    if (value == null) return null;
    if (_hotList is EqualUnmodifiableListView) return _hotList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  final List<TokenModel>? _tokenList;
  @override
  List<TokenModel>? get tokenList {
    final value = _tokenList;
    if (value == null) return null;
    if (_tokenList is EqualUnmodifiableListView) return _tokenList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'SearchTokensState.initial(tokensMap: $tokensMap, letterList: $letterList, showSearchResult: $showSearchResult, searchResultList: $searchResultList, hot1: $hot1, hot2: $hot2, hot3: $hot3, hot4: $hot4, hotList: $hotList, tokenList: $tokenList)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitialImpl &&
            const DeepCollectionEquality()
                .equals(other._tokensMap, _tokensMap) &&
            const DeepCollectionEquality()
                .equals(other._letterList, _letterList) &&
            (identical(other.showSearchResult, showSearchResult) ||
                other.showSearchResult == showSearchResult) &&
            const DeepCollectionEquality()
                .equals(other._searchResultList, _searchResultList) &&
            (identical(other.hot1, hot1) || other.hot1 == hot1) &&
            (identical(other.hot2, hot2) || other.hot2 == hot2) &&
            (identical(other.hot3, hot3) || other.hot3 == hot3) &&
            (identical(other.hot4, hot4) || other.hot4 == hot4) &&
            const DeepCollectionEquality().equals(other._hotList, _hotList) &&
            const DeepCollectionEquality()
                .equals(other._tokenList, _tokenList));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_tokensMap),
      const DeepCollectionEquality().hash(_letterList),
      showSearchResult,
      const DeepCollectionEquality().hash(_searchResultList),
      hot1,
      hot2,
      hot3,
      hot4,
      const DeepCollectionEquality().hash(_hotList),
      const DeepCollectionEquality().hash(_tokenList));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      __$$InitialImplCopyWithImpl<_$InitialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
            Map<String, List<TokenModel>>? tokensMap,
            List<String>? letterList,
            bool? showSearchResult,
            List<TokenModel>? searchResultList,
            TokenModel? hot1,
            TokenModel? hot2,
            TokenModel? hot3,
            TokenModel? hot4,
            List<TokenModel>? hotList,
            List<TokenModel>? tokenList)
        initial,
  }) {
    return initial(tokensMap, letterList, showSearchResult, searchResultList,
        hot1, hot2, hot3, hot4, hotList, tokenList);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            Map<String, List<TokenModel>>? tokensMap,
            List<String>? letterList,
            bool? showSearchResult,
            List<TokenModel>? searchResultList,
            TokenModel? hot1,
            TokenModel? hot2,
            TokenModel? hot3,
            TokenModel? hot4,
            List<TokenModel>? hotList,
            List<TokenModel>? tokenList)?
        initial,
  }) {
    return initial?.call(tokensMap, letterList, showSearchResult,
        searchResultList, hot1, hot2, hot3, hot4, hotList, tokenList);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            Map<String, List<TokenModel>>? tokensMap,
            List<String>? letterList,
            bool? showSearchResult,
            List<TokenModel>? searchResultList,
            TokenModel? hot1,
            TokenModel? hot2,
            TokenModel? hot3,
            TokenModel? hot4,
            List<TokenModel>? hotList,
            List<TokenModel>? tokenList)?
        initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(tokensMap, letterList, showSearchResult, searchResultList,
          hot1, hot2, hot3, hot4, hotList, tokenList);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements SearchTokensState {
  const factory _Initial(
      {final Map<String, List<TokenModel>>? tokensMap,
      final List<String>? letterList,
      final bool? showSearchResult,
      final List<TokenModel>? searchResultList,
      final TokenModel? hot1,
      final TokenModel? hot2,
      final TokenModel? hot3,
      final TokenModel? hot4,
      final List<TokenModel>? hotList,
      final List<TokenModel>? tokenList}) = _$InitialImpl;

  @override
  Map<String, List<TokenModel>>? get tokensMap;
  @override
  List<String>? get letterList;
  @override
  bool? get showSearchResult;
  @override
  List<TokenModel>? get searchResultList;
  @override
  TokenModel? get hot1;
  @override
  TokenModel? get hot2;
  @override
  TokenModel? get hot3;
  @override
  TokenModel? get hot4;
  @override
  List<TokenModel>? get hotList;
  @override
  List<TokenModel>? get tokenList;
  @override
  @JsonKey(ignore: true)
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
